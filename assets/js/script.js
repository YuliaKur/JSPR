// "use strict"; //- современный режим в нем работаяют некоторые неточности которые были в старых версиях JS, прописввается только в начале кода


                    // ОБЬЯВЛЕНИЕ ПЕРЕМЕННОЙ

    // Имя переменной может содержать только буквы, лучше латинского алфавита,
    // цифры и символы. При этом первый символ не должен быть цифрой

    // Правильное обьявление переменной

            // let age;
            // let info123;
            // let $size;
            // let _color;
            // let leftBorderWith;

    // Обьявление нескольких переменных

            // let myName = "Вася";
            // let myAge = 36;
            // let myMessage = "Привет мир!";
         
            // или
         
            // let myName = "Вася",
                // myAge = 36,
                // myMessage = "Привет мир!";

    // Изменение значения переменной

            // let myAge = 36;
            // myAge = 18;
            // console.log(myAge); консоль: 18

    // Копируем значение одной пременной в другую переменную

            // let myAge = 36;
            // let myNewAge = 18;
            // myAge = myNewAge;
            // console.log(myAge); консоль: 18
          
    // Область видимости переменных  
        
        // Видимость пременной только внутри блока инструкций

        //     function testBlock() {
        //         let myAge = 36;
        //         console.log(myAge); консоль:36
        //     }
        //     testBlock();

        //     console.log(myAge); переменная н видна за пределами блок консоль выдаст ошибку

        //     let myAge = 18;              переменная внутри и за пределами блока это две разные переменные 
        //     function testBlock() {       даже если у них одинакокое название
        //         let myAge = 36;
        //         console.log(myAge); консоль:36
        //     }
        //     testBlock();

        //     console.log(myAge); консоль:18 


    // Константа

        // Названия переменных для const которые нельзя менять и лучше придерживаться такого правила их написания
                // например:
                // const snake_case          имя конст. со значением присвоенным в процессе выполнения программы
                // const UPPER_SNEKE_CASE    так записывают имена константы с зарание известным значением
                // const _api_Base

        // Смена значений в крнстанте

                // const userProfile = {
                //     name: 'Вася',
                //     age: 36,
                //     messege: 'Привет мир'
                // }
                // console.log(userProfile); консоль:{ name: 'Вася', age: 36, messege: 'Привет мир' }
                
                // userProfile.age = 18;   меняется значение одного из полей обьекта

                // console.log(userProfile);  консоль:{ name: 'Вася', age: 18, messege: 'Привет мир' }

    //  Ключевое слово VAR 
    
        // Использование переменной до ее обьявления

            // age = 15;
            // console.log(age); 
            // var age;

        //  Область видимости переменной   

            // function testBlockVar() {
                // var myAgeVar = 36;
            // }
            // testBlockVar();
            // console.log(myAgeVar); переменная не видна за пределами блока


            // if (true) {
            //     var sizeVar = 50;
            // }
            // console.log(sizeVar); переменная видна за пределами блока также будет происходить с циклами и т.д


// Задание 1
// let userName = "John";
// let userNumber = 25;

// userNumber = 24;

// console.log(userName + userNumber);







                                    // ТИПЫ ДАННЫХ  JS

//    JS является динамически типизированным. То есть тип данных переменной меняется динамически 
//      в момент присвоения либо смены ее значения, а не в момент обьявления.
                                    
// typeof -  позволяет определить тип параметра (число, строка, объект).

            // let userName; обьявляем переменную
            // console.log(typeof userName);  Консоль: undefined
            // let userName = "Привет мир";
            // console.log(typeof userName); Консоль: string
            // let userName = 58;
            // console.log(typeof userName); Консоль: number

        // Простые Типы
        //     Числа 1,2,3  number
        //     Строки "strin", "name"
        //     Логический тип (boolean)
        //     null
        //     undefined
        //     Symbol
        //     Biglnt
        //     Function

 
// Обьекты
// Спец. Обьекты:
// Массивы []
// Функции function
// Обьект Даты
// Регулярные выражения
// Ошибки

// Обычные обьекты


// const obj = {
//     name: "John",
//     age: 25,
//     isMarried: false
// };









                                    // МАСИВЫ. Методы

// массив не является отдельным типом данных, они основаны на обьектах

    // Длина массива

// length() - является свойством объекта функции и указывает, сколько аргументов ожидает функция, то есть, количество формальных параметров
            // arr.length ('дима', 'катя');
            // console.log(arr);

    // Работа с очередью и стеком

// push() - добавляет неограниченное количество элементов в конец массива
            // arr.push ('дима', 'катя');
            // console.log(arr);

// shift() - удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива
            // arr.shift ('дима', 'катя');
            // console.log(arr);

// pop() - удаляет последний элемент из массива и возвращает его значение.
            // arr.pop ('дима', 'катя');
            // console.log(arr);

// unshift() - добавляет один или более элементов в начало массива и возвращает новую длину массива
            // arr.unshift ('дима', 'катя');
            // console.log(arr);

    // Редактирование элементов массива        

// splice() -  изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
        // удаляем переменную
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // arrTwo.splice(1, 1);
                // console.log(arrTwo);
        // возвращаем переменную
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // let removed = arrTwo.splice(1, 1);
                // console.log(removed);
        // заменяем один элемент на другой
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // Ваня заменяем на Юля
                // arrTwo.splice(0, 1, 'Юля); ноль это позиция эелемента, 1 количество заменяемых элементов, 'Юля' на что заменяем
                // console.log(arrTwo);
        // добавляем элемент
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // larrTwo.splice(1, 0, 'Маша', 'Юля'); одни означает перед первой позицией, ноль означает что чтото добавляем, 
                                                    //  дальше через запятую указываем элементы которые хотим добавить ('Маша', 'Юля')
                // console.log(arrTwo);
        // удаляем элемент массива
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // начиная с последней позиции (Оля) удаляем один элемент
                // arrTwo.splice(-1, 1); минус одни означает с конца позиция, одни означает что один элемент
                // console.log(arrTwo);

    // Копирование массивов

// slice () - возвращает новый массив, содержащий копию части исходного массива.
                // let arrOne = ['Ваня', 'Коля', 'Оля',]

                // копировать будет начиная с первой позиции (Коля)
                // до второй позиции Оля
                //  let arrTwo = arrOne.slice(1, 2);
                // console.log(arrTwo);

                // начиная с предпоследней позиции Коля, тоесть с права на лево
                // до последней позиции Оля не включая Оля
                //  let arrTwo = arrOne.slice(-2, -1);
                // console.log(arrTwo);

                // Копируем весь массив
                //  let arrTwo = arrOne.slice();
                // console.log(arrTwo);

                // const oldArray = ['a', ['b'], ['c']];
                // const newArray = oldArray.slice();

                // newArray[1] = 'sdggdhdhhdhf';
                // console.log(newArray);    [ 'a', 'sdggdhdhhdhf', [ 'c' ] ]
                // console.log(oldArray);    [ 'a', [ 'b' ], [ 'c' ] ]







// concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого 
                    //с другими массивами и/или значениями, переданными в качестве аргументов
                // let arrOne = ['Ваня', 'Коля', 'Оля',]
                //  let arrTwo = arrOne.concat('Петя'); через заяпятую можно добавить сколько угодно данных
                // console.log(arrTwo); данные добявяться в конце массива

    // Поиск в массиве

// indexOf() - возвращает индекс первого вхождения указанного значения в строковый объект String , 
            // на котором он был вызван, начиная с индекса fromIndex . Возвращает -1, если значение не найдено

                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // console.log(arr.indexOf('Коля'));в круглых скобках пишем то что хотим найти в массиве (Коля)
                // console.log(arr.indexOf('Коля', 2));в круглых скобках пишем то что хотим найти в массиве (Коля)
                //                                      двойка ознаяает что ищем со второй позиции


// lastIndexOf() - возвращает индекс последнего вхождения указанного значения в строковый объект String ,
            //  на котором он был вызван, или -1, если ничего не было найдено. Поиск по строке ведётся от конца к началу, 
            //  начиная с индекса fromIndex .


// includes() - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false .
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // console.log(arr.includes('Коля')); в круглых скобках пишем то что хотим найти в массиве (Коля)
                // console.log(arr.indexOf('Коля', 2));в круглых скобках пишем то что хотим найти в массиве (Коля)
                //                                      двойка ознаяает что ищем со второй позиции

    // Поиск в массиве объектов

// find() - возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции.
//          В противном случае возвращается undefined               
//         если true возвращает текуший элемент и перепор обьектов прекращается
//         если все итерации оказались ложными  возвращается undefined
                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // 
                // let resultOne = arr.find(function(item, index, array) {      item сам элемет массива, index ключ или позиция массива
                    // return item.age === 18;                                  array это весь масив
                // });
                // 
                // или
                // 
                // let resultOne = arr.find(item => item.age === 18);
                // 
                // console.log(resultOne);
                // 

// findIndex() - возвращает индекс (ключ) в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1
                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // let resultOne = arr.findIndex(item => item.age === 18);
                // 
                // console.log(resultOne);


// filter() - создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
            // если true элемент добавляется и перебор продолжается
            // возвращается пустой массив если ничего не найдено

                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // let resultOne = arr.filter((function(item, index, array) {
                //     return item.age >= 18;
                // }
                // console.log(resultOne);

    // Сортировка массива

// sort() - сортирует элементы массива и возвращает отсортированный массив.

        // Сортировка слов
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',]    
        //         console.log(arrTwo.sort());
                    // в консоль выведит сортировку в алфавитном порядке


        // Сортировка чисел
        //         let arrTwo = [8, 22, 1,]    
        //         console.log(arrTwo.sort());

                // функция сортировки
                // function compareNumber (a, b) {
                //     if (a > b) return 1;
                //     if (a == b) return 0;
                //     if (a < b) return -1;

                        // или

                        // return a - b
                // }

                // console.log (arrTwo.sort(compareNumber));

                // или вместо функции сортировки написать вот так

                // console.log (arrTwo.sort((a, b) => a - b)); выведит в консоль такой же массив [1, 8, 22,]


// reverse() - на месте переставляет элементы массива, на котором он был вызван, изменяет массив и возвращает ссылку на него.
            // меняет порядок элементов в масиве на обратный
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',];    
        //         console.log(arrTwo.reverse());  выведит в консоль такой же массив ['Оля', 'Коля', 'Ваня',]

    // Преобразование массива

//  map() - принимает первым параметром функцию. Дальше, внутри себя, map() перебирает элементы переданной коллекции и для каждого
//           элемента вызывает переданную функцию. На вход этой функции передаётся элемент исходного массива, а её результат
//           записывается в новый массив, который и возвращается наружу.
            // вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',]; 
        // let result = arr.map((function(item, index, array) {   //item сам элемет массива, index ключ или позиция массива
        //         return item[0];                                  //array это весь масив
        //     });

        //     или

        // let result = arr.  map(item => item[0]);
        //         console.log(arr);  выведит в консоль такой же массив ['Ваня', 'Коля', 'Оля',]
        //         console.log(result);  выведит в консоль такой же массив ['В', 'К', 'О',] 

// split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
//           преобразует строку в массив по заданому разделителю 

              
              
        // let str = 'Ваня, Коля, Оля';
        // let arr = str.split(',');     заданный разделитель (,) можем указать любой разделитель какой нас интересует
        // console.log(arr);             выведит в консоль массив ['Ваня', 'Коля', 'Оля']
        // 
        // 
        // let arrTwo = str.split(',', 2); ограничение в вывод в массив до 2 элементов
        // console.log(arrTwo);            выведит в консоль массив ['Ваня', 'Коля']


        
// join() - объединяет все элементы массива (или массивоподобного объекта) в строкуjoin
         // преобразует массив в строку с заданым разделителем
         
                    //  let arr = ['Ваня', 'Коля', 'Оля',];
                    //  let str = arr.join(',');      заданный разделитель (,) можем указать любой разделитель какой нас интересует
                    //  console.log(arr);             выведит в консоль строку где строка разделена указаным разделителем   (Ваня, Коля, Оля)


                    //  let arrTwo = ['Ваня', 'Коля', 'Оля',];
                    //  console.log(String(arrTwo));   тот же будет результат если мы просто используем метод String
                    //                                 но при методе стринг мы не можем уазать метод разделения и он всегда будет запятая


// Array.isArray() - возвращает true , если объект является массивом и false, если он массивом не является.

                    // let obj = {};
                    // let arr = [];

                    // if (Array.isArray(arr)) {                  в скобках указываем переменную которую хотим понять массив это или нет
                    //     console.log ('Это массив!');           в этом случае значение будет true консаль выдаст 'Это массив!'
                    // } else {
                    //     console.log('Это не массив!');         
                    // }

                    // if (Array.isArray(obj)) {                  
                    //     console.log ('Это массив!');           
                    // } else {
                    //     console.log('Это не массив!');        в этом случае значение будет false консоль выдаст  'Это не массив!'
                    // }

    // Перебор элементов массива

    //                 let arr = ['Ваня', 'Коля', 'Оля',];
    //                 console.log(arr.length);

    // цикл FOR
    //                 можем получить значение и ключ массива


    //                 for (let i = 0; i < arr.length; i++) {
    //                     console.log(arr[i]);                    консоль выведет Ваня Коля Оля
    //                 }

    // цикл FOR...OF
    //                 можно  использовать для вывода значений

                    // let arr = ['Ваня, Коля, Оля',];
            
                    //        for (let arrItem of arr) {            //  let arrItem переменная которая будет содержать в себе каждое значение массива
                    //     console.log(arrItem);           //    консоль выведет Ваня Коля Оля 
                    // }

    // forEach - выполняет функцию для каждого элемента массива

                    // let arr = ['Ваня', 'Коля', 'Оля',];

                    // arr.forEach(function (item, index, array) {                                 
                    //     console.log(`${item} находиться на ${index} позиции в ${index}`);   item сам элемет массива, index ключ или позиция массива, array это весь массив
                    //                                                                         консоль выведет: Ваня находиться на 0 позиции в 0
                    //                                                                         Коля находиться на 1 позиции в 1
                    //                                                                         Оля находиться на 2 позиции в 2
                    // });



                    // const arr = [2, 3, 6, 8, 10];

                    // arr.forEach(function(item, i, arr) {
                    //     console.log(`${i}: ${item} внутри массива ${arr}`);
                    // });  консоль 0: 2 внутри массива 2,3,6,8,10
                    //              1: 3 внутри массива 2,3,6,8,10
                    //              2: 6 внутри массива 2,3,6,8,10
                    //              3: 8 внутри массива 2,3,6,8,10
                    //              4: 10 внутри массива 2,3,6,8,10



        // тоже самое можно записать в стрелочную функцию   

                    // arr.forEach((item, index, array) => {
                    //     console.log(`${item} находиться на ${index} позиции в ${index}`);
                    // });

        //  или

                    //  arr.forEach(show);     также можно указывать имя отдельной функции 

                    //  function show(item) {
                    //     console.log(item);   консоль выведет Ваня
                    //                                          Коля
                    //                                          Оля
                    //  }


// reduce()   reduceRight() используються для вычисления какого-нибудь единого знаения на основе всего массива
// reduce() - приводит массив к единому значению, то есть редуцируя (сокращая, сводя) его

            // let value = arr.reduce(function(previousValue, item, index, array) {            previousValue - результат предыдущего вызова этой функции, 
            //                                                                                       равен initial при первом вызове (если передан initial)
            //     ...                                                                               item - очередной элемент массива, index его индекс, array сам массив            
            // }, [initial]);                                                                        функция применяется по очереди ко всем элементам массива и 
            //                                                                                       "переносит" свой результат на следующий вызов    

                    // let arrOne = [1, 2, 3, 4];
                    // let reduceValueOne = arrOne.reduce(function(previousValue, item, index, array) {   обьявляем переменную let reduceValueOne, обращаемся к массиву чисел
                    //     return item + previousValue;                                                   в теле функции мы возвращаем сумму текущего значения массива с предыдущим  previousValue                                         
                    // }, 0);                                                                             начальное значение  для  previousValue ставим 0

                    // console.log(reduceValueOne);                                                       консоль выдаст число 10

            // как получилась цифра 10
            // шаг №1
            // previousValue = 0     мы указали ноль  "" }, 0); ""          
            // item = 1              у нас одни let arrOne = ["""1""", 2, 3, 4]                          
            // их сумма = 1          сумма их 1                    

            // шаг №2   
            // previousValue = 1     значение 1 так как результат предыдущей функции 1 (сумма шага №1)
            // item = 2              у нас теперь два let arrOne = [1, """2""", 3, 4] 
            // их сумма = 3          сумма их 1+2=3

            // шаг №3   
            // previousValue = 3      значение 3 так как результат предыдущей функции 3 (сумма шага №2)
            // item = 3               у нас теперь два let arrOne = [1, 2, """3""", 4]
            // их сумма = 6           сумма их 3+3=6

            // шаг №4   
            // previousValue = 6      значение 6 так как результат предыдущей функции 6 (сумма шага №3)
            // item = 4               у нас теперь два let arrOne = [1, 2, 3, """4"""]
            // их сумма = 10          сумма их 6+4=10

    // Если не указывать начальоне значание, то оно будет равно первому элементу массива (previousValue=Ваня)
    // А работа ментода начинается со второго элемента (item = Коля)

    // let arrTwo = ['Ваня', 'Коля', 'Оля',];

    // let reduceValueTwo = arrTwo.reduce(function(previousValue, item, index, array) { 
    //     console.log(previousValue);
    //     console.log(item);
    //     return `${item}, ${previousValue}`;
    // });                                               начальное значение неустановлено
    // console.log(`Пользователи: ${reduceValueTwo}`);   консоль выведит: Ваня
    //                                                                    Коля
    //                                                                    Коля, Ваня
    //                                                                    Оля
    //                                                                    Пользователи: Оля, Коля, Ваня

// reduceRight() - применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению
             //    работает аналогично только проходит по массиву справо налево



// console.log(obj.name); первый способ вывода в консоль
// console.log(obj["name"]); 


// let arr = ["plum.png", "orange.jpg", 6, "apple.bmp", {обьект}, [массив]] Класический массив
// console.log(arr[1]) чтобы вывести с массыва какойто обьект мы должны указать номер под которым он лежит
//                     нумерация начинается с нуля тоесть plum.png под номером ноль


// const arr = ['a','b','c']; - массив это перечень информации по порядку

// const arrObj = {  - массив это частный случай обьекта 
//     0: "a",
//     1: "b",
//     2: "c"
// };

// console.log(arr[1]); выведит b
// console.log(arrObj[1]); 


// const obj = {a: 1, b: 2}; - обьекты структура хранения данных в парном формате        

// const obj = {
//    "Anna": 500, ключ это Anna значение 500

//    "Alice": 800
//     Alice: 800 две одинаковые записи
// };

// const arr = ['a','b','c'];
// const arrObj = { 
//     a: 'a',
//     '1': 'b',
//     2: 'c'
// };

// arrObj.b = '1234'; - одинаковые записи
// arrObj['b'] = '1234';

// console.log(arrObj['b']); 
// console.log(arrObj.b); 



// Задание 2

// let storeName = 'Products';
// let storeDescription = {
//     budget: 10000,
//     employees: ['Jon', 'Mark', 'Sava'],
//     products: {
//         apples: 100,
//         orange: 300
//     },
//     open: true    

// };




                                    // ПРОСТОЕ ОБЩЕНИЕ С ПОЛЬЗОВАТЕЛЕМ

// Вся информация которая приходит от пользователя будет ввиде строки

// prompt - показывает сообщение и запрашивает ввод текста от пользователя.
// alert - показывает сообщение.
// confirm - показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false,
//           если нажата кнопка «Отмена» или Esc с клавиатуры


// alert('Hello')

// const result = confirm("Are you here?");
// console.log(result);

// const answer = prompt("Вам есть 18?", "18");
// console.log(typeof(answer)); выведит строку

// const answer = +prompt("Вам есть 18?", "18"); "+" тип данных строка преобразуется в тип данных цифры
// console.log(answer + 5); выведит сумму  чисел

// const answers = [];

// answers[0] = prompt('Как ваше имя?', '');
// answers[1] = prompt('Как ваша фамилия?', '');
// answers[2] = prompt('Сколько вам лет?', '');
// answers[3] = prompt('Где вы учититесь?', '');

// document.write(answers);





                                        // ИНТЕРПОЛЯЦИЯ(ES6)

// это когда в нутри строки мы можем вставлять переменные

// const category = 'toys';
// console.log('https://someurl.com/' + category);

// интерполяцию мы можем использовать только с косыми кавычками ``
// const category = 'toys';
// console.log(`https://someurl.com/${category}/5`);

// const user = 'Ivan';
// alert(`Привет,${user}`);






                                        // ОПЕРАТОРЫ JS

// Операторы могу быть двух типолв увеличеные и бинарные

// Операнд - это то к чему применяется оператор, или их еще называют аргументами

            // let userAge = 30 - 6;  Числа 30 и 6 это операнды
            // let userHeight = h - y; перерменные h, y тоже операнды( аргументы)

// Бинарными называют операторы которые применяються к двум операндам
// в нашем случае вычитание это бинарный оператор

//             let userAge = 30 - 6;  минус это бинарный оператор который прим к двум аргумтам

// Унарным считается операто, который применяется к одному операнду

//                 let userCash = -800;
 
// в JS поддерживаються такие математические операции

        // let x;
        // Сложение +
        //  х = 5 + 8;
        //  console.log(`Результа сложения: ${x}`);

        //  Вычитание -
        //  х = 9 - 5;
        //  console.log(`Результа вычитания: ${x}`);

        // Умножения *
        // х = 2 * 3;
        //  console.log(`Результа умножения: ${x}`);

        // Деления /
        // х = 10 / 2;
        // console.log(`Результа деления: ${x}`);

        // Взятие остатка от деления %
        // х = 11 typeof3;
        // console.log(`Результа взятие остатка от деления: ${x}`);
        // Проверка: 11=3 *3 (неполное частичное от деления) + 2(остаток)

        // Возведение в степень **
        // х = 5 ** 3;
        // console.log(`Результа возведения в степень: ${x}`);
        // Число 5 умноженое на себя 3 раза 5*5*5 = 125

    // Применение оператора сложения к строкам

    //     let resultOne = "Фамилия" + " " + "Имя" + " " + "Отчество";
    //     console.log(resultOne);  консоль: Фамилия Имя Отчество

    // Если в выражении есть строка, то есть то конечный результат тоже будет строкой 
        
    //     let resultTwo = "Фамилия " + 25;
    //     console.log(resultTwo); Консоль: Фамилия 25 

    // порядок и значение не имеет 

    //     let resultTwo = 25 + " Фамилия";
    //     console.log(resultTwo); консоль: 25 Фамилия

    // let resultTwo = 25 + "40";
    // console.log(resultTwo); консоль: 2540

// Унарный оператор сложения

//     Со строками

//         let resultOne = +"25";
//         console.log(resultOne); консоль: 25

//     С цифрами
//         let resultOne = +"25";
//         console.log(resultOne); консоль: 10

        // let user = "25";
        // let admins = "10";
        // console.log(user + admins); консоль: 2510  если применить к бинарному оператору то получитьсч 2510

        // console.log(+user + +admins); консоль: 35 если применить к унарному то получим сложение 25+10=35
        // более длинная запись 
        // console.log(Number(user) + Number(admins)); консоль: 35

    // Приоритеты операторов
    // Умножение и деление выполниться раньше чем сложение и вычитание
    // у собок самый высокий приоритет
    // если у операторов одинаковый приоритет то действия будут выполняться по очереди

// = оператор присваивания
    // let a = 1 + 2; переменной а присваеваем резельтат сложения 1 + 2
    
    // присваивание по цепочке 
    //  let = resultOne = resultTwo = resultThree = 1 + 2; из-за приоритетов сначало выполниться результат 1+2 

        // сокращенная запись вычисления с присваением

        //     let user = 5;
        //     user = user + 3;
        //     user = user * 2;

        //     Можно записать так 

        //     let user = 5;
        //     user += 3;
        //     console.log(user); консоль: 8

        //     user *= 2;
        //     console.log(user); консоль: 16


// Инкремент и декремент 


    // Инкремент
            // let addUser = 2;
            // addUser++;
            // console.log(addUser);
            // работает также как и 
            // addUser = addUser + 1;
            // илиaddUser += 1;

    // Декремент
            // let removedUser = 2;
            // removedUser--;
            // console.log(removedUser);
        // Инкремент / Декремент можно применить только к переменной 
        // попытка использовать его на значении, типа 5++, приведет к ошибке

// Постиксная форма      
    // ncr++;
    // ecr--;
    // let userCounter = 0;
    // let newUser = userCounter++;
    // console.log(newUser); консоль: 0

//Префиксная форма
    // ++incr;
    // --decr;

        // let userCounter = 0;
        // let newUser = ++userCounter;
        // console.log(newUser); консоль: 1

    // Если нам срузу не нужно получить результат, а нужно только увеличить / уменьшить переменну, 
    // тогда без разницы какую форму использовать

    // Если нужно сразу получить результат то применяем префиксную форму

    // Если нужно увеличить / уменьшить переменную при этом получить значение до получения результата то применяем постфиксную форму

    // Инкремент / Декремент можно применять в любых вырвжениях, при этом приоритет их будет выше,
    // чем у большинства других арифметических операций

        // let userCounter = 0;
        // let newUser = 2 * userCounter++; сначала выполниться инкримент и только потом умножение
        // console.log(newUser); консоль: 2

// Оператор запятая
 
    // Предоставляет возможность вычислять несколько выражений, разделяя их запятой
    // Каждое выражение выполняется,ю но возвращается результат только последнего

    //         let userCounter = (8 + 2, 19 + 1); ве операции выполняться но результа в консоль выведет полько последнего выражения (19+1)
    //         console.log(userCounter); консоль: 20

// Побитовые операторы
        // AND (и)  ( & )
        // QR (или) ( | )

// Операторы сравнения

    // Возвращают логический тип данных со значением true или false

        // Больше: a > b
        // Меньше: a < b
        // Больше или равно: a >= b
        // Меньше или равно: a <= b
        // Равно: a == b
        // Не равно: a != b
        // Строгое равно: a === b
        // Строгое не равно: a !== b

            // console.log(2 > 1); консоль: true
            // console.log(4 < 2); консоль: false
            // console.log(58 == 36); консоль: false
            // console.log(8 != 9); консоль: true

            // let result = 11 > 10;
            // console.log(result); консоль: true

    // Сравнивание строк

        // Алгорит сравнения двух строк простой:
        //     1. сначала сравниваються первые символы строк
        //     2. если первый символ строки больше(меньше) чем первый символ втрой, 
        //        топервая строка больше(меньше) второй. Сравнение завершино
        //     3. если первые символы равны, то таким же образом сравниваються 
        //         уже вторые символы строк
        //     4. сравнивание продолжается, пока не закончиться одна из строк
        //     5. если обе строки заканчиваються одновременно
        //         то они равны. Иначе больше считается более длинная строка

        // JS использует алфавитны й порядок при этом сравнивает строки по символьно тоесть в алфавитном порядке
            
        //     console.log('Б' > 'А'); консоль: true
        //     console.log('Скрипт' > 'Скрипка'); консоль: true

        //     в этом варианте будет сравнивать по количеству символов
        //     console.log('Слайдер' > 'Слайд'); консоль: true

        //     в таблице символов иникод которую использует js маленькие буквы имеют приоритет
        //     console.log('Слайдер' > 'слайдер'); консоль: false


    // При сравнении разных типов данных js будет приводитьть их в число

                // console.log('58' > 10); консоль: true    строка 58 превратиться в число 58
            //     console.log('007' == 7); консоль: true   строка 007 превратиться в цифру

    // Логические значения true будут становиться 1, а false - 0

                // console.log(true == 1); консоль: true       true превратиться в 1 и тогда выражение правдивое
                // console.log(false == 0); консоль: true      false превратиться в ноль


    // Оператор строго раавениства / не равенства проверяет равенство без приведения типов
        // оператор проверяет без приведения типов, тоесть в число преобразовываться ничего не будет
        
                    // console.log(0 === false); консоль: false        ноль не равен false
                    // console.log('007' === 7); консоль: false        строка 007 не равна 7
                    // console.log('58' !== 58); консоль: true         строка 58 не равна число 58

    // Сравнение null и undefined
 
        // строгое равенство

        //     console.log(null === undefined); консоль: false

        // не строгое равенство

        //     console.log(null == undefined); консоль: true

        // сравнение null и 0

        //     console.log(null > 0); консоль: false
        //     console.log(null == 0); консоль: false
        //     console.log(null >= 0); консоль: true

        // сравнение undefined и 0

        //     console.log(undefined > 0); консоль: false
        //     console.log(undefined == 0); консоль: false
        //     console.log(undefined >= 0); консоль: false


    // Чтобы исбежать проблем при сравнивании нужно очень осторожно к любому сравниванию с undefined / null
    // кроме случаев строгого раавениства
    
    // Не использовать сравнения >=,  >,  <, <= с переменными, которые могут принимать значения null / undefined
    
    // если переменная принимает эти значения то стоит добавить для них отдельные проверки


// Логические операторы

    //Оператор ||  "или" 

        // Процес работы ||:
        //     1. вычисляет операнды слева направо
        //     2. каждый операнд конвертирует в логическое значение 
        //     если результат true, останавливается и возвращает исходное значение этого операндам
        //     3. если все операнды являються ложными false, возвращает значение последнего из них

        // булевые значения
            // console.log(true || true); консоль: true
            // console.log(false || true); консоль: true
            // console.log(true || false); консоль: true
            // console.log(false || false); консоль: false

        // разные типы данных

        //     первыей true это 1
        //     console.log(1 || 0); консоль: 1

        //     первыей true это true
        //     console.log(true || 'ИМЯ'); консоль: true

        //     первыей true это 58
        //     console.log(null || 58); консоль: 58

        //     первыей true это ИМЯ
        //     console.log(null || 'ИМЯ' || 0); консоль: ИМЯ

        //     true нет совсем, вернеться последние значение 0
        //     console.log(undefined || '' || null || 0); консоль: 0

                // let userName = '';
                // let userNickName = 'Имя';.

                // let user = userName || userNickName || "Без имени"; true будет Имя, выполнение кода прирвется и в консоль выведит Имя
                // console.log(user); консоль: Имя

            // let admins = 0;
            // let users = 5;
            // admins > users || users++;      сначала выподняется выражение больше(admins > users) это будет false
            //                                  потом выражение ИЛИ false|| users++(users++ будет true и увиличется на 1)
            // console.log(users);  консоль: 6

    // Оператор && (И)

        // && оператор "и" возвращает значение true только если все значение true
        
        // Выполняет такие действия:
        //     1. Вычисляет операнды слева на правдивое
        //     2. каждый операнд преобразует в логическое значение если результат false, 
        //         останавливается и возвращает исходное значение этого операнда
        //     3. если все операнды были true, возвращает значение последнего

        // Булевые значения
        //     console.log(true && true); консоль: true
        //     console.log(false && true); консоль: false
        //     console.log(true && false); консоль: false
        //     console.log(false && false); консоль: false

        // Разные типы данных

            // ноль будет первый false значить выполнение прерветьбся и выведет 0
            // console.log('ИМЯ' && 0 && 2 && 3); консоль: 0

            // null будет первый false значить выполнение прерветьбся и выведет null
            // console.log(1 && 2 && null && 3); консоль: null

            // все значения будут true
            // console.log('15' && '42'); консоль: 42

        // Приоритет оператора && больше чем ||

            // console.log(1 && 0 || 2 && 1); консоль: 1

            // let users = 1;
            // (users > 0) && console.log(`Пользователей ${users}`);       Сначала выполняется выражение в скобках (users > 0) это будет true
                                                                        // потом console.log(`Пользователей ${users}`) это будет true
                                                                        // в итоге консоль выведет console.log(`Пользователей ${users}`)
                                                                        // если выражение (users > 0) будет false то в консоль ничего не выведет
                                                                        // потомучто процес будет остановлен на первом операнде

    // Оператор ! (НЕТ)                                                                     

        // Выполняет такие действия:
            // 1. Сначала приводит апгумент к логическому типу true / false
            // 2. затем возвращает противоположное значение
        
        // Булевые значения
            //  console.log(!true); консоль: false 

        // Разные типы данных
            // console.log(!null); консоль: true
            // console.log(!1); консоль: false
            // console.log(!''); консоль: true
            // console.log(!'Имя'); консоль: false

        // Опрератор ! (НЕ) имеет найвысший приоритет, поэтому он всегда выполняется первым, перед && или ||

            // console.log(!true && 58 || 18 && !1); консоль: false    Сначала выполниться оператор ! (!true) станет false, а !1 станет нулем
                                                                    // потом выполниться оператор && (!true && 58) будет false и (18 && !1) тоже будет false
                                                                    // потом выполниться оператор || (!true && 58false и (18 && !1) false будет false
        
        // иногда двойной оператор !! используют для преобразования в булевый тип
                // console.log(!! 'Имя'); консоль: true
                
                //     или
        
                // console.log(Boolean('Имя')); консоль: true    Boolean специальная функция


    // Оператор сравнения с null(??)

            // Оператор ?? возвращает первый аргумент, если он не null / undefined, иначе второй

                // let names;
                // console.log(names ?? "Без имени");   консоль: Без имени
                // let names = 'Имя';
                // console.log(names ?? "Без имени");   консоль: Имя      как только переменную присваеваем значение в консоль выведет это значение


 

        // const hamburger = 3;
        // const fries = 1;

        // if (hamburger === 3 && fries) {         hamburger === 3 - эта часть кода будет выполняться первой так как у оператора === (строгое равно) приоритет по выполнению    &&& (и) этот оператор будет выполняться вторым
        //     console.log('Все сыты!');                             мы сравниваем сколько должно быть hamburger
        // } else {
        //     console.assert.log('Мы уходим');
        // }


        // оператор и (&&) всегда возвращает первое ложное значение если оно есть на нем код останавливается и дальше код не идет
        //                 если все аргументы верны и код дошел до конца то возвращается значение последнего аргумента

        //                 и (&&) запинается на лжи 
        //                 или (||) запинается на правде


        // const hamburger = 3;
        // const fries = 0;
        // const cola = 0;

        // if (hamburger || cola || fries) {       как только оператор или (||) находит правду он перестает работать
        //     console.log('Все сыты!');
        // } else {
        //     console.assert.log('Мы уходим');
        // }



        // let johnReport, alexReport, samReport, mariaReport = 'done';

        // console.log(johnReport || alexReport || samReport || mariaReport);
        // оператор или вернул правду даже если она стоит в конце списка


        // const hamburger = 3;
        // const fries = 3;
        // const cola = 0;
        // const nuggets = 2;

        // if (hamburger === 3 && cola ===2 || fries === 3 && nuggets) {
        //     console.log('Все сыты!');
        // } else {
        //     console.assert.log('Мы уходим');
        // }

        // console.log(hamburger === 3 && cola ===2 || fries === 3 && nuggets);
        // ответ 
        // Все сыты!
        // 2


        // console.log( 5 === 5 && 3 > 1 || 5);
        // сначала выполняется 3 > 1 у оператора больше приоритет перед другими операторами
        // потом выполняется строгое равенство 5 === 5
        // потом выполняется логическое И '&&'
        // и в последний момент выполняется оператор ИЛИ '||'
        // ответ будет 'true'
        //           Оператор возвращает строку, содержащую тип ('number', 'string' , 'object' ). 
        //           Для null оператор возвращает 'object' (это признанная ошибка языка)


    // Оператр Spread 

    //     Spread syntax позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах

    //         для функций: где ожидаемое количество аргументов для вызовов функций
    //               равно нулю или больше нуля
    //         для элементов (литералов массива)
    //         для выражений объектов: в местах, где количество пар "ключ-значение"
    //               должно быть равно нулю или больше (для объектных литералов)

        // Для массивов

                // const video = ['youtube', 'vimeo', 'rutube'],
                //       blogs = ['wordpress', 'livegornal', 'blogger'],
                //       internet = [...blogs, ...video, 'vk', 'facebook'];
                //       console.log(internet);[
                //                                 'wordpress',
                //                                 'livegornal',
                //                                 'blogger',
                //                                 'youtube',
                //                                 'vimeo',
                //                                 'rutube',
                //                                 'vk',
                //                                 'facebook'
                //                             ]



                    // function log(a, b, c) {
                    //     console.log(a);
                    //     console.log(b);
                    //     console.log(c);
                    // }

                    // const num = [2, 5, 7];
                    // log(...num);    2
                    //                 5
                    //                 7

        // Для обьектов

                // const a = {
                //     one: 1,
                //     two: 2,
                // };
                // const newObj = {...a};
                // console.log(a);     { one: 1, two: 2 }





// ПРАКТИКА
/* Задание на урок:

1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
'Сколько фильмов вы уже посмотрели?'

2) Создать объект personalMovieDB и в него поместить такие свойства:
    - count - сюда передается ответ на первый вопрос
    - movies - в это свойство поместить пустой объект
    - actors - тоже поместить пустой объект
    - genres - сюда поместить пустой массив
    - privat - в это свойство поместить boolean(логическое) значение false

3) Задайте пользователю по два раза вопросы:
    - 'Один из последних просмотренных фильмов?'
    - 'На сколько оцените его?'
Ответы стоит поместить в отдельные переменные
Записать ответы в объект movies в формате: 
    movies: {
        'logan': '8.1'
    }

Проверить, чтобы все работало без ошибок в консоли */



// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = prompt('На сколько оцените его?', ''),
//       c = prompt('Один из последних просмотренных фильмов?', ''),
//       d = prompt('На сколько оцените его?', '');

// personalMovieDB.movies[a] = b;
// personalMovieDB.movies[c] = d;

// console.log(personalMovieDB);








                        // УСЛОВИЯ

    // Если условие в круглых скобках if (2 > 1) true то код будет выполнятся
    // Есл false то код выполняется не будет

                // let messege = 'Привет';

                // if (2 > 1) {                   Код выполниться только если выражение в скобках вернет true
                //     console.log(messege);      2 > 1 это true и код выведет в консоль Привет
                // }  
                
                
                // let messege = 'Привет';
                // let first = 5;
                // let second = 10;

                // if (first === second) {
                //     console.log(messege);  в консоль ничего не выведет так как выражение false
                // }


                // let messege = 'Привет';

                // if ( 2 + 1 === 3 && "1" == 1 || 10 > 5 && 10 === 1) { 
                //     console.log(messege); консоль: Привет
                // }

            // Более короткая запись
            //     let messege = 'Привет';

            //     if (2 > 1) console.log(messege);



                // let messege = 'Привет';
                // let number = 5;

                // if (number > 1) {
                //     console.log(messege);
                // } else {
                //     console.log('Условие не выполнено!');
                // }

    // Чтобы проверить несколько условий мы можем использовать блок if else 

                // let messege = 'Привет';
                // let number = 5;
                // if (number > 50) {
                //     console.log('5 больше 50');
                // } else if (number > 30) {
                //     console.log('5 больше 30');
                // } else if (number > 10) {
                //     console.log('5 больше 10');
                // } else if (number > 1) {
                //     console.log('5 больше 1');  консоль: 5 больше 1
                // } else {
                //     console.log('Условие не выполнено!');
                // }

    // Тернарный оператор
        // Условный оператор вопросительный знак ?

        // (num === 50) ? console.log('Ok!') : console.log('Error');
            // Класическая запись кода
                // let message = 'Привет';
                // let messageEnd;

                // if (5 > 1) {
                //     messageEnd = ", Вася!";
                // } else {
                //     messageEnd = ", Оля!";
                // }

                // message += messageEnd;
                // console.log(message);   консоль: Привет, Вася!
                
            // код переписан с помощью оператора ?
                
                // let message = 'Привет';
                // let messageEnd = (5 > 1) ? ", Вася!" : ", Оля!";  ( : ) двоеточие заменяет else

                // message += messageEnd;
                // console.log(message);   консоль: Привет, Вася!


            // Более сложная запись кода

                // let message = 'Привет';
                // let messageEnd;

                // if (5 > 50) {
                //     messageEnd = ", Вася!";
                // } else if (5 > 30) {
                //     messageEnd = ", Оля!";
                // } else if (5 > 10) {
                //     messageEnd = ", Миша!";
                // } else if (5 > 1) {
                //     messageEnd = ", Андрей!";
                // } else {
                //     messageEnd = ", Коля!";
                // }

                // message += messageEnd;
                // console.log(message);   консоль: Привет, Андрей!

            // Упрощенная запись

                // let message = 'Привет';
                // let messageEnd = 5 > 10 ? ", Вася!" :
                //     5 > 30 ? ", Оля!" :
                //         5 > 10 ? ", Миша!" :
                //             5 > 1 ? ", Андрей!" :
                //             ", Коля!";

                // message += messageEnd;
                // console.log(message);   консоль: Привет, Андрей!









// const num = 50;

// конструкция
// switch всегда идет на строгое сравнение в отличии от обычных условий
// switch (num) {
//     case 49:
//         console.log('Неверно');
//         break;
//     case 100:
//         console.log('Неверно');
//         break;
//     case 50:
//         console.log('В точку!');
//         break;
//     default:
//         console.log('Не в этот раз!');
//         break;    
// }






                                    // ЦИКЛЫ

    // Цикл «WHILE»

        // while – Проверяет условие перед каждой итерацией.

                // while (Условие) {
                //     тело цикла
                //     тут будет выполняться код
                // }

        // если true цикл проверяет, если false цикл прерывается

                    // let num = 0;

                    // while (num < 5) {
                    //     console.log(num);  консоль: 0 1 2 3 4
                    //     num++;
                    // }


                    // let num = 5;

                    // while (num) {
                    //     console.log(num);  консоль: 5 4 3 2 1 
                    //     num--;
                    // }

            // упращенная запись
                    //     let num = 5;
                    //     while (num) console.log(num--);


    // Цикл «DO...WHILE»

        // do..while – Проверяет условие после каждой итерации.
        // Используют тогда когда нужно чтобы прошло одно выполнение тела цикла в не зависимости от того вернет условие true или нет

                    // let i = 0;
                    // do {
                    //   alert( i );
                    //   i++;
                    // } while (i < 3);

    // Цикл «FOR»

        // for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

                // for (Начало; Условие; Шаг) {
                //     Тело цикла
                //     Здесь будет выполняться код
                // }

                // for (let num = 0; num < 5; num++) {
                //     console.log(num);
                // }

            // Работа цикла for:
            //     1) Выполняется начало - let num = 0
            //     2) Выполняется условие - num < 5
            //     3) Если условие true выполняется тело цикла - console.log(num)
            //     4) Выполняется шаг - num++ 
            //     5) Повтор начиная с пункта №2

                // for (let i = 0; i < 3; i++) { //консоль: выведет 0, затем 1, затем 2
                //     alert(i);
                // }

                // let num;       Обьявление переменной вне цикла
                // for(num = 0; num < 5; num++) {
                //     console.log(num);                   консоль: 0 1 2 3 4 
                // }
                // console.log(`Вывод вне цикла: ${num}`); консоль: Вывод вне цикла: 5

                // let result = '';
                // const length = 7;
                // for (let i = 1; i < length; i++) {
                //     for ( let j = 0; j < i; j++) {
                //         result += '*';
                //     }
                //     result += '\n';
                // }
                // console.log(result); 
                // консоль:*
                //         **
                //         ***
                //         ****
                //         *****
                //         ******
                
        // Можно убрать любую часть цикла

                // let num = 0;
                // for (; num < 5; ) {      Если убрать условие num < 5 то цикл будет бесконечный
                //     console.log(num);    консоль: 0 1 2 3 4
                    // num++;
                // }

    // Деректива BREAK

            // break полностью прекращает выполнение цикла, отличная штука для тех ситуаций, когда условие,
            //  по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела

                    // let num = 0;
                    // for (; num < 5; num++) {
                    //     console.log(num);              консоль: 0 1 2
                    //     if (num == 2) break;
                    // }
                    // console.log(`Работа окончена, num = ${num}`); консоль: Работа окончена, num = 2

    // Деректива CONTINUE

            // continue прекращает (перепрыгивает) выполнение тела цикла и передаёт управление на следующую итерацию for

                    // let num = 0;
                    // for (; num < 5; num++) {
                    //     if(num == 2) continue;
                    //     console.log(num);     консоль: 0 1 3 4
                    // }

        // Дерективы break и continue нельзя использовать вместе с оператором вопросительный знак ( ? )

    // Метки цикла

        // Метки - единственный способ для break / continue выйти за пределы текущего цикла,
        //  повлиять на выполнение внешнего

                // firstFor: for (let num = 0; num < 2; num++) {   firstFor - это метка
                //     for (let size = 0; size < 3; size++) {
                //         if (size == 2) {
                //             break firstFor;   остановиться родительский цикл так как у него есть метка
                //         }
                //         console.log(size);  консоль: 0 1 
                //     }
                // }

        // Также метка будет работать и с дерективой continue

                // firstFor: for (let num = 0; num < 2; num++) {   firstFor - это метка
                //     for (let size = 0; size < 3; size++) {
                //         if (size == 2) {
                //             continue firstFor;   остановиться родительский цикл так как у него есть метка
                //         }
                //         console.log(size);  консоль: 0 1 0 1
                //     }
                // }

    // Метки не позволяют перемещаться по коду куда мы захотим вызов break или continue с меткой должны быть внутри цикла,
    //  а сама метка должна быть присвоена выше записи
               


// Задачи#3

//     1, При помощи цикла выведите числа от 5 до 10 в консоль. 5 и 10 включительно. Цикл можно использовать любой

// for (let i = 5; i < 11; i++) {
//     console.log(i);
// }

//   2,  При помощи цикла for вывести числа от 20 до 10 в консоль. 
// В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 13 - остановить весь цикл

// for (let i = 20; i > 10; i--) {

//    if (i === 13) { 
//     break;
//    }

//     console.log(i);

// }

//   3,  При помощи цикла for выведите чётные числа от 2 до 10 включительно

// for (let i = 2; i <= 10; i++) {

//     if (i % 2 === 0) {

//         console.log(i);
//     }

// }

//   4,  Перепишите цикл  for на вариант с while. Результат должен остаться точно таким же. 
// Не создайте бесконечный цикл! Иначе браузер может зависнуть.

//          Цикл, который нужно переписать:
//          
        //  for (let i = 2; i <= 16; i++) {
        //      if (i % 2 === 0) {
        //          continue;
        //      } else {
        //          console.log(i);
        //      }
        //  }


// let i = 2;

// while (i <= 16) {

    
//     if (i % 2 === 0) {
//         i++;
//         continue;
//     } else {
//         console.log(i);
//     }
//     i++;
// }

//   5,  Заполните массив цифрами от 5 до 10 включительно. 
// Помните, что элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

// const arrayOfNumbers = [];

// for (let i = 5; i < 11; i++) {
//     arrayOfNumbers.push(i);
    
// }
    
// console.log(arrayOfNumbers);
    
// второй вариант
// const arrayOfNumbers = [];

// for (let i = 5; i < 11; i++) {
//     arrayOfNumbers[i - 5] = i;
// }

// console.log(arrayOfNumbers);




// Задачи: #4

//    1 Заполните новый массив (result) числами из старого (arr).
//  Количество элементов в массиве можно получить как arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд.
//     Должен получиться точно такой же массив

    // const arr = [3, 5, 8, 16, 20, 23, 50];
    // const result = [];

    // for (let i = 0; i < arr.length; i++) {

    //         result [i] = arr[i];
    // }
    // console.log(result);



//    2 Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
//     Для определения типа данных используйте typeof();
//     Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]

    // const data = [5, 10, 'Shopping', 20, 'Homework'];
    
    // for (let i = 0; i < data.length; i++) {
    //     if (typeof(data[i]) === 'number') {
    //         data [i] = data [i] * 2;
    //     } else if (typeof(data[i]) === 'string'){
    //         data[i] = `${data[i]} - done`;
    //     }
    // }
    // console.log(data);




//    3 Разверните массив data наоборот при помощи цикла и запишите данные в пустой массив result.
//     Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]

    // const data = [5, 10, 'Shopping', 20, 'Homework'];
    // const result = [];

    // for (let i = 1; i <= data.length; i++) {
        
    //     result[i - 1] = data[data.length - i];
    // }
    // console.log(result);





// Задача №5

// Сейчас вам необходимо написать код, который при помощи звездочек (*) в консоли нарисует вот такую фигуру:

//          *
//         ***
//        *****
//       *******
//      *********
//     ***********

// const lines = 5;
// let result = '';


// for (let i = 0; i<= lines; i++) {
//     for (let j = 0; j < lines - i; j++) {
//         result += ' ';
//     }
//     for (let k = 0; k < 2 * i + 1; k++) {
//         result += '*';        
//     }
// result += "\n";
// }

// console.log(result);



// let	s = 0,
//     i = 0,
//     j,
//     size = 5,
//     board = '',
//     out = '';

// while(s < size -1){
//   out += ' ';
//   s++;
// }

// while(i< size){
//   board += '# ';  
//   console.log(out, board);
//   out = out.substring(0, out.length - 1);
//   i++;
// }  консоль: 

//     # 
//    # # 
//   # # # 
//  # # # # 
// # # # # # 



/* Задание на урок:

1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит - 
возвращаем пользователя к вопросам опять

3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
"Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
"Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

4) Потренироваться и переписать цикл еще двумя способами*/

// 'use strict';

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };


// for (let i = 0; i < 2; i++) {
//     const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = prompt('На сколько оцените его?', '');


//     if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
//             personalMovieDB.movies[a] = b;
//             console.log('done');
//       } else {
//           console.log('arror');
//           i--;
//       }
//     }

//       if (personalMovieDB.count < 10) {
//         console.log('Просмотрено довольно мало фильмов');
//       } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//         console.log('Вы классический зритель!');
//       } else if (personalMovieDB.count >= 30) {
//         console.log('Вы киноман))))');
//       } else {
//         console.log('Произошла ошибка');
//       }

      
// console.log(personalMovieDB);








                                //   ФУНКЦИИ


    // Обьявление функции (Function Declaration)

        //             function имя (параметры) {
        //                 тело функции
        //             }

        // в имени функции используються определенные префиксы, обозначающие действие,
        // после которых следует обьект действия

            // функции начинающие с :

            //         "show...." - обычно что-то проверяют,
            //         "get..." - возвращают значение,
            //         "calc..." - что-то вычисляют,
            //         "create..." - что-то создают,
            //         "check..." - что-тто проверяют и возвращают логическое значение, и т.д.
            // например:
            //         showMessage - показать сообщение
            //         getOptions - получить параметры
            //         calcSum - посчитать сумму

                // function showMessage() {
                //     console.log('Сообщение');
                // }

                // showMessage();

        // Запускать функцию мы можем перед самой функцией, после функии и множество раз


                // showMessage();

                // function showMessage() {
                //     console.log('Сообщение');
                // }

                // showMessage();
                // showMessage();
                // showMessage();

    // Вложеность и видимость функции

                    // 'use script'

                    // if (2 > 1) {
                    //     function getSumm() {
                    //         let numOne, numTwo;
                        
                    //         function getNumOne() {
                    //             numOne = 1;
                    //         }
                        
                    //         function getNumTwo() {
                    //             numTwo = 1;
                    //         }
                        
                    //         getNumOne();
                    //         getNumTwo();
                        
                    //         let numSumm = numOne + numTwo;
                    //         console.log(numSumm);
                    //     }
                    // }

                    // getSumm(); консоль: ошибка

        // Внешняя переменная

                            // let messege showMessage() { внешняя переменная
                            //     messege = 'Сообщение';
                            // }

                            // showMessage();
                            // console.log(messege); если вывести переменную в консоль до обьявления функции консоль выдаст undefined

                // Если обьявить внешнюю и внутреннюю переменную содинаковым именем это будут две разные перерменные

        // Глобальная переменная

            // Глобальная переменная - внешняя переменная обьявлена за пределами всех  функций
                // эту переменную видно в середине каждой функции и за ее пределами


                // let globalVar = 'Я глобальная переменная'

                // function getSumm() {
                //     let numOne, numTwo;
                
                //     function getNumOne() {
                //         numOne = 1;
                //     }
                
                //     function getNumTwo() {
                //         numTwo = 1;
                //     }
                
                //     getNumOne();
                //     getNumTwo();
                
                //     let numSumm = numOne + numTwo;
                //     console.log(numSumm);
                // }
                //   console.log(globalVar);  

                // getSumm(); консоль: 


        // Параметры функции (аргумены)

                        // function calcSumm(numOne, numTwo) {
                        //     console.log(`Переменная numOne: ${numOne} `);
                        //     console.log(`Переменная numTwo: ${numTwo} `);

                        //     let numSumm = numOne + numTwo;

                        //     console.log(`Сумма: ${numSumm}`);
                        // }

                        // calcSumm(1, 2); консоль: Сумма: 3

            // Если мы в функцию при вызове не передадим никах переменных то функция будет возвращать undefined

                        // function calcSumm(numOne = 1, numTwo = 2) {     указано значение по умолчанию
                        //     console.log(`Переменная numOne: ${numOne} `);
                        //     console.log(`Переменная numTwo: ${numTwo} `);

                        //     let numSumm = numOne + numTwo;

                        //     console.log(`Сумма: ${numSumm}`);
                        // }

                        // calcSumm(); консоль: Сумма: 3 в момент передачи параметра будет использоваться значение по умолчанию
                                                    // но если параметры передадим то будут уже использоваться переданные параметры

        // Функции-колбэки

                // если функции в коде идут одна за другой это не значить что они также будут срабатывать
                    // они запускаються одна за одной но результат могут отдать в разное время

                    // function calcSumm(numOne, numTwo, more, less) {
                    //     let numSumm = numOne + numTwo;

                    //     if (numSumm > 3) {
                    //         more();
                    //     } else {
                    //         less();
                    //     }
                    // }

                    // function showMoreMessage() {
                    //     console.log('Больше чем 3');
                    // }

                    // function showLessMessage() {
                    //     console.log('Меньше чем 3');
                    // }

                    // calcSumm(1, 5, showMoreMessage, showLessMessage); консоль:Больше чем 3

        // Возврат результата

                    // function calcSumm(numOne, numTwo) {
                    //     let numSumm = numOne + numTwo;

                    //     Возврат
                    //     result numSumm; правильный вариант записи

                    //     return       вот такой записи не должно быть это ошибка и все
                    //     numSumm;      что стоит ниже return выполняться не будет 

                    //     дальше код не будет выполняться
                    // }
                    
                    // let funcRezult = calcSumm(1, 2); 

                    // console.log(`Сумма: ${funcRezult}`); крнсоль: 3

                // return может записываться без значения это нужно тогда когда нужно прекратить работу функции
        
        // Рекрусия

                // Рекрусия - это когда функция вызывает саму себя 

                    // function calcSumm(numOne, numTwo)   {
                    //   let result = 1;
                    //        умножаем result на numOne раз в цикле
                    //  for (let i = 0; i < numTwo; i++) {
                    //     result *= numOne;
                    //  }

                    // return result;

                    // }
                    // console.log(calcSumm(2,3)); консоль: 8


                    // function calcSumm(numOne, numTwo)   {
                    //     if (numTwo === 1) {
                    //         return numOne;
                    //     } else {
                    //         return numOne * calcSumm(numOne, numTwo - 1);    функция calcSumm в определенный период вызывает саму себя
                    //     }                                                    передавая другие параметры, это и есть рекрусия.
                    // }                                                        Количество таких вложеных вызовов называется глубиной рекрусии
                    // console.log(calcSumm(2, 3)); консоль: 8                  и ограничивается JS, но можно расчитывать на 10 тыс вызовов.

        // Функциональное выражение (Function Expression)

                // когда строиться функциональное выражение то вызвать мы можем его только после его создания
                    
                    // let showMessage = function () { чтобы построить функциональное выражение достаточно  обьявить переменную и присвоить ей функцию без имени
                    //     console.log('Привет!');     других отличей нет
                    // };
                    // showMessage(); консоль: Привет!

                // когда мы обьявляем функцию мы можем вызвать ее из любого места программы до  обьявления функции, после обьявления  и т.д.

                    // function getSumm() {
                    //     let summ = 1 + 2;
                    //     console.log(summ);
                    // }

                    // let someVar = getSumm;    в момент копирования функция не выполняется так как нет круглых скобок

                    // someVar(); консоль: 3     можно вызвать саму функцию или непосредственно чере переменную
                    // getSumm(); Консоль: 3

            // Чаще всего для создания функции используют обьявление функции (Function Declaration) но также функциональные выражения имеют место быть
            
                //   if (2 > 1) {
                //         function getSumm() {
                //             let summ = 1 + 2;
                //             console.log(summ);
                //         }
                //    }
                //    getSumm(); Консоль: ошибка так как функция обьявлена в какомто блоке абсолютно не видна за его пределами
            
            // для этого нам нужно переменную обьявить за пределами блока

                        // let getSumm;

                        // if (2 > 1) {
                        //     getSumm = function () {
                        //             let summ = 1 + 2;
                        //             console.log(summ);
                        //     };
                        // }

                        // getSumm();

        // Стрелочные функции (Arrow functions)

                // класическое функциональное выражение:
                //     let имя переменной = function (параметр,....параметр) {
                //         return выражение;
                //     };

                // Стрелочная функция
                    // let имя переменной = (параметр,...параметр) => выражение;

                // Однострочная стрелочная функция
                    // let getMessage = (text, name) => text + ', ' + name +'!';
                    // console.log( getMessage('Привет', 'Вася')); консоль: Привет, Вася!

                // Многострочная стрелочная функция
                    // let getMessage = (test, name) => {
                    //     let messege = text + ', ' + name + '!';
                    //     return message;
                    // };

                    // console.log(getMessage('Привет', 'Вася'));

        // Планирование: setTimeout и setInterval

                // Чтобы реализовать планирование существуют два метода:
                //     1) setTimeout позволяет вызвать функцию один аз через определенный интервал времени

                //             setTimeout(функция или код, задержка, параметр,...параметр);

                                // function showMessage(text, name) {
                                    // console.log(`${text}, ${name}!`);
                                // }
                                // 
                                // setTimeout(showMessage, 3000, 'Привет', 'Вася'); 3000 это 3секунды


                                // function showMessage(text, name) {
                                //     console.log(`${text}, ${name}!`);
                                //     setTimeout(showMessage, 500, 'Привет', 'Вася');
                                // }
                                
                                // setTimeout(showMessage, 500, 'Привет', 'Вася'); такая запись когда setTimeout вызывается два раза даст более точную задержку


                                // function showNumber(num) {
                                //     console.log(num);
                                //     if (num < 10) {
                                //         setTimeout(showNumber, 1000, ++num);
                                //     }
                                // }
                                // setTimeout(showNumber,1000, 1); консольвыведет цифры от 1 до 10 с задержкой в 1сек
        

                                // function showNumber(num) {
                                //     console.log(num);
                                //     let timeId = setTimeout(showNumber, 1000, ++num);
                                //     if (num === 6) {
                                //         clearTimeout(timeId); останавливает работу setTimeout обьявленого ранее
                                //     }
                                // }
                                // setTimeout(showNumber,1000, 1);


                //     2) setInterval позволяет вызвать функцию регулярно, повторяя вызов через определенный интервал времени

                //             setInterval(функция или код, задержка, параметр,...параметр);

                                // function showMessage(text, name) {
                                    // console.log(`${text}, ${name}!`);
                                // }
                                // 
                                // setInterval(showMessage, 500, 'Привет', 'Вася'); консоль: Привет, Вася!

                                
                                // let result = 0;
                                // function showNumber(num) {
                                //     result += num;
                                //     console.log(result);
                                //     if (result === 5) {
                                //         clearInterval(timeId);  останавливает работу  setInterval обьявленого ранее
                                //     }
                                // }
                                // let timeId = setInterval(showNumber,1000, 1);

                                
                            //          Функция соединения строк
                            // function createMessage(text, name) {
                            //     return `${text}, ${name}!`;
                            // }
                            //          Функция вывода в консоль
                            // function showMessage(message) { 
                            //     console.log(message);
                            // }
                            //          обьединяющая функция, вызывает обе функции
                            // function initMessage(text, name) {
                            //     showMessage(createMessage(text, name));
                            // }
                            // initMessage('Привет', 'мир'); консоль: Привет, мир!

                // Если понадобиться то можно по отдельности вызвать каждую функцию в течении кода
 




/* Задачи:

1) Создайте функцию, которая будет на вход принимать 1 аргумент с именем человека и возвращать строку.

Пример: вызов функции sayHello('Антон') возвращает строку "Привет, Антон!". В решении вызывать функцию не нужно, 
программа сделает это за вас.

P.S. возвращать - это использовать ключевое слово return.

P.S.S. Это классическая функция-модификатор, которых мы дальше по курсу будем создавать еще много в разных видах.*/

    // function sayHello(name) {
    //     console.log(`Привет, ${name}!`);
    //     return `Привет, ${name}!`;
    // }

    // sayHello('Андрей');


/*2) Создайте функцию, которая принимает в себя 1 аргумент в виде целого числа и возвращает массив из трех чисел:
 одно на 1 меньше, сам аргумент, и число на 1 больше.

Пример: вызов функции returnNeighboringNumbers(5) возвращает массив в виде [4, 5, 6].*/


// function returnNeighboringNumbers(num) {
//     console.log([num - 1, num, num + 1]);
//     return [num - 1, num, num + 1];
// }

// returnNeighboringNumbers(5);


/*3) Создайте функцию, которая будет принимать в себя 2 аргумента, оба числа. Первое число - это база, второе число - это
 сколько раз нужно будет повторить это число в прогрессии. (Смотри пример ниже). Функция должна возвращать строку
  (или число в особых случаях, о которых ниже), где эти числа идут по порядку, разделенные тремя дефисами "---". 
  После последнего числа их не должно быть.

Если второй аргумент не является числом, равен или меньше нуля - то возвращать просто первый аргумент. 
(Проверяем через оператор typeof)

Примеры:

Вызов функции getMathResult(5, 3) даст ответ 5---10---15

Вызов функции getMathResult(3, 10) даст ответ 3---6---9---12---15---18---21---24---27---30

Вызов функции getMathResult(10, 5) даст ответ 10---20---30---40---50

Вызов функции getMathResult(10, '5') даст ответ 10

Вызов функции getMathResult(10, 0) даст ответ 10

Вызов функции getMathResult(20, -5) даст ответ
        
// function getMathResult(oneNum, twoNum) {
//     if (typeof(twoNum) !== 'number' || twoNum <= 0) {
//         console.log(oneNum);
//         return oneNum;
//   
//     let str = 
//     for(let i = 1; i <= twoNum; i++){
//         if(i === twoNum){
//            str += `${twoNum * i}`;
//         } else {
//             str += `${twoNum * i}---`;
//         }
//     }
//     console.log(str);
//     return str;
/
// getMathResult(8, 








                
                                                // ЧИСЛА

                //    let someNum = 458;
                //    console.log(someNum);
                   
                //    let someNum = 4.58;          десятичные числа обязательно нужно записывать через точку 
                //    console.log(someNum);        никаких запятых!!!!!!!!
           
                //    let someNum = 1e6;        1 латинская буква "e" число 6 означает количество нулей 
                //    console.log(someNum);     фактически это происходит так  1*1000000

                //    let someNum = 1e-6;       1 латинская буква "e" число 6 означает количество нулей
                //    console.log(someNum);     фактически это происходит так  1 / 1000000

            // Шестнадцатеричные, двоичные и восмеричные числа

                    // Шестнадцатеричные числа широко используються в JS для представления цветов, 
                        // кодировки символов и много другого

                        // console.log(0xFF); 0x указывает на шестнадцатеричную систему
                        //                    FF  это кодировка
                        
                    // Реже используються двоичные и восьмеричные числа

                    // console.log(0b11111111); 0b двоичная система исчисления 
                    // console.log(0o377);      0o восьмеричные система исчисления

            // Системы счисления. toString()

                    // Метод toString(base) возвращает строковое представление числа в той или иной системе счисления (base)
                    // base может принимать значения от 2 до 36 (по умолчанию 10)

                        // let num= 255;                     пример перекодирования числа 255 
                        // console.log(num.toString(16));    в шестнадцатеричную
                        // console.log(num.toString(8));     в восьмеричную
                        // console.log(num.toString(2));     в двоичную систему исчисления

            // Округление чисел

                    // в JS встроенный обьект Math, который содержит несколько функций для работы с округлением
                    
                    // Math.typeof - округление в меншую строну

                        // let numOne = Math.floor(5.8);
                        // let numTwo = Math.floor(2.2);
                        // let numThree = Math.floor(-2.2);

                        // console.log(numOne);    консоль:  5
                        // console.log(numTwo);    консоль:  2
                        // console.log(numThree);  консоль:  -3

                    // Math.ceil - округление в боьшую сторону
                    
                        // let numOne = Math.floor(5.8);
                        // let numTwo = Math.floor(2.2);
                        // let numThree = Math.floor(-2.2);

                        // console.log(numOne);    консоль:  6
                        // console.log(numTwo);    консоль:  3
                        // console.log(numThree);  консоль:  -2

                    // Math.round - округляетдо ближайшего целого
                        
                        // let numOne = Math.floor(5.8);
                        // let numTwo = Math.floor(2.2);
                        // let numThree = Math.floor(-2.2);

                        // console.log(numOne);    консоль:  6
                        // console.log(numTwo);    консоль:  2
                        // console.log(numThree);  консоль:  -2

                    //  Способ отделение и деления
                     
                        //  let numOne = Math.round(5.845 * 10) / 10;      5.845 * 10 = 58.45 дальше 58.45 спомощью Math.round округляем 58
                        //  console.log(numOne);                           дальше 58 / 10 и получем 5.8

                        //  let numOne = Math.round(5.845 * 100) / 100;   584.5 -> 585 -> 5.85
                        //  console.log(numOne);                          консоль: 5.85 

                        //  let numOne = Math.round(5.8449 * 100) / 100;   584.49 -> 584 -> 5.84
                        //  console.log(numOne);                          консоль: 5.84

                    // Метод toFixed(n) - округляет число до n знаков после запятой и возвращает строковое представление результата

                        // let numOne = 5.845;                     в скобках указываем то количество знаков какое хотим получить после запятой
                        // console.log(numOne.toFixed(1));         консоль: 5.8
                        //                                         в резельтате получаем строку в которой написано 5.8        
                        // console.log(+numOne.toFixed(1));         чтобы преобразовать эту строку в число можем использовать унарный операто "+"
                        // console.log(Number(numOne.toFixed(1)));  или функцию Number, в обеих случаях получим число

            // Проблема неточных вычислений

                        // let numOne = Math.round(1.005 * 100) / 100;  ожидаем в консоль: 1.01
                        // console.log(numOne);                         консоль:  1       

                        // let numOne = 12.35;                          ожидаем в консоль: 12.4
                        // console.log(numOne.toFixed(1));              консоль:  12.3

                        // let problem = 0.1 + 0.2 === 0.3;
                        // console.log(problem);                  консоль: false
                        // console.log(0.1 + 0.2);                консоль: 0.30000000000000004



                        // let sourseNum = 1.005;
                        // let numOne = Math.round(sourseNum * 100) / 100;
                        // console.log(numOne);                       консоль:  1              
                        
                        // console.log(sourseNum * 100);              консоль:  100.49999999999999
                        // console.log(Math.round(sourseNum * 100));  консоль:  100

                // с помощью Number.EPSILON мы можем округлить число и получить верный ответ

                        // let sourseNum = 1.005 + Number.EPSILON;
                        // let numOne = Math.round(sourseNum * 100) / 100;
                        // console.log(numOne);                       консоль:  1.01

            // Проверка: isFinite и isNaN

                    // специальные числовые значения isFinite и isNaN
                    // isFinite - бесконечность
                    // isNaN - ошибка вычисления
                    // эти значения также являються типом данных number но не являються обычными числами
                    // для проверки таких значений существуют специальные функции

                // проверка isNaN

                    // console.log(Number(25 + "Привет!"));   консоль: NaN (это ошибка вычисления)
                    // console.log(isNaN(25 + "Привет!"));    консоль: true тоесть это дествительно ошибка вычисления


                    // if(25 + "Привет!") {
                    //     console.log('Я не NaN');  консоль: Я не NaN
                    // }

                    // console.log(NaN === NaN);   консоль: false NaN никогда не будет равен NaN
                                                // именно поетому используется специальная функция проверки

                // проверка isFinite

                    // преобразует аргумент в число и возвращает true, если оно является обычным числом

                        // console.log(isFinite("25"));      "25" -> 25 -> true
                        // console.log(isFinite("Привет!")); NaN -> false
                        // console.log(isFinite(10 / 0));    Infinity -> false
                        
            // parseInt и parseFloat

                    // Для получения числел и строк "150px" существуют parseInt и parseFloat
                    // Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число

                    // parseInt - возвращает целое число
                    // parseFloat - возвращает число с плавающей точкой

                            // let valueOne = parseInt("150.58px");
                            // console.log(valueOne);                консоль: 150
                            // console.log(typeof valueOne);         консоль: number

                            // let valueOne = parseFloat("150.58px");
                            // console.log(valueOne);                консоль: 150.58
                            // console.log(typeof valueOne);         консоль: number

                            // let valueOne = parseFloat("а150.58px"); если первым символом строки будет не число тоесть сразу возникнет ошибка 
                            //                                         то верненся NaN так как никакого число с этой строки мы достать не можем
                            // console.log(valueOne);                консоль: NaN 
                            // console.log(typeof valueOne);         консоль: number

                    // Функция parseInt имеет необязательный второй параметр
                    // Он определяет систему счисления, таким образом parseInt
                    // может также читать строки с шестнадцатиричными, двоичными и т. д. числами

                        // console.log(parseInt('0xff', 16));
                        // console.log(parseInt('ff', 16));


            // Некоторые функции Math

        //   Math.random() - возвращает псевдослучйное число в диапазоне от 0(включительно) до 1(но не включая 1)
            
                    // console.log(Math.random());  консоль:  0.045563284455810926
                    // console.log(Math.random());  консоль:  0.02877643514962669
                    // console.log(Math.random());  консоль:  0.307529480337817

        // Math.max(a, b, c...) и Math.min(a, b, c...) - возвращает найбольшее/найменшее число из выше перечисленных

                    // console.log(Math.max(5, 85, -49));  консоль:  85
                    // console.log(Math.min(5, 85, -49));  консоль:  -49

        // Math.abs() - возвращает абсолютное значение(модуль ) числа

                    // let num = -58;
                    // console.log(Math.abs(num));    консоль:  58

        // Math.pow(n, power) - возвращает число n, возведенное в степень power

                    // console.log(Math.pow(5, 8));  вернеться 5 в 8 степени консоль: 390625








                                                                    // СТРОКИ

            // Строку можно создать с помощью одинарных, двойных или обратных кавычек   
            // Одинарные и ввойные кавычки работают, по сути, одинаково, а если использовать обратные,
            //  то строку мы можем вставлять производные выражения, обернув их в ${...}


                    // let textHi = "Привет!";
                    // let textAll = `${textHi} Я строка!`;

                    // console.log(textAll);   консоль: Привет! Я строка!

                    // function someSum(a, b) {
                    //     return a + b;
                    // }

                    // console.log(`Сума: ${someSum(4, 7)}`);  консоль: Сума: 11


                    // let text = `Привет!     с помощбю обратных кавычек можно делать перенос текта консоль выведет текст 
                    // Как тебя зовут?           консоль:    Привет!
                    // Я Федя))`;                            Как тебя зовут?
                    //                                       Я Федя))
                    // console.log(text);
                                                                    
            // Все что заключено в любые кавычки будет иметь тип данных сторока

                    // let someString = "158";
                    // let someNum = 158;

                    // console.log(someString);         консоль: 158
                    // console.log(typeof someString);  консоль: string
                    // console.log(someNum);            консоль: 158
                    // console.log(typeof someNum);     консоль: number

                    // console.log(someString + someNum);  консоль: 158158

    // Спецсимволы

            // Внутри строк можно использовать ряд спецсимволов
            // Все спецсимволы начинаються с обратного слеша  
            // \ - так называемого символа экранирования

                // \n - перевод строки
            
                    // let textTwo = "Привет!\nКак тебя зовут?\nЯ Федя))";
                    // console.log(textTwo);   консоль:  Привет!
                    //                                   Как тебя зовут?
                    //                                   Я Федя))

                // \t - отступ(табуляция)
                                
                    // let textTwo = "Привет!\n\tКак тебя зовут?\n\t\tЯ Федя))";
                    // console.log(textTwo);   консоль:  Привет!
                    //                                     Как тебя зовут?
                    //                                         Я Федя))

                // \\ - обратный слеш

                    // чтобы в тексте показать обратный слеш нужно его записать два раза "\\"

                    // let textTwo = "Привет! Как тебя зовут? \\ Я Федя))";
                    // console.log(textTwo);   консоль:  Привет! Как тебя зовут? \ Я Федя))
                                                        
                // \' \" - кавычки

                    // let textTwo = "Привет! Как тебя зовут? \' Я Федя))\'";
                    // console.log(textTwo);   консоль:  Привет! Как тебя зовут? ' Я Федя))'

                // Иконки, символы UTF-16 \uКод и UTF-32 \u{код}

                    // let textTwo = "Привет! Как тебя зовут? \u00A9  Я Федя\u{1F60D}";
                    // console.log(textTwo);   консоль:  Привет! Как тебя зовут? ©  Я Федя😍

    // Длинна строки

            // свойство length

            //         let textOne = "Привет!";
            //         console.log(textOne.length); консоль: 7 количество символов в Привет!

                // let text = 'Привет!';
                // let firstSymbol = text[0];     получаем символ строки это буква П
                // let lastSymbol = text[text.length - 1]; получаем символ строки  это !

                // console.log(firstSymbol);  консоль: П 
                // console.log(lastSymbol);   консоль: !

                // for (const char of text) {
                //     console.log(char); в консоле будет выводиться каждый символ отдельно
                // }

                // вот таким способом нельзя изменить символ в строке 

                    // let text = "Привет!";
                    // text[6] = "?";
                    // console.log(text); как видно ничего не получилось поменять

    // изменение регистра строки(размера символа)

                    // let text = 'Привет';
                    // console.log(text.toUpperCase());  все символы станут большими ПРИВЕТ
                    // console.log(text.toLowerCase());  все символы станут маленикими привет

    // Метод str.indexOf(substr, pos) - он ищет подстроку substr в строке str, начиная с позиции pos и возвращает позицию,
            //                                  на которой распологается совпадение, либо -1 при отсутствии совадений

                // indexOf стоит использовать тогда когда нам нужна позиция найденой подстроки
                //     в остальных случаях удобнее испоьзовать includes

                    // let text = 'Привет!';
                    // console.log(text.indexOf('рив'));     консоль: 1 рив находиться начиная с первой позиции 
                    // console.log(text.indexOf('рив', 3));  консоль: -1 значить совпадение не найдено так как мы начинаем искать начиная с 3 позиции

    // Метод includes - возвращает true если в строке найдено совпадение илбо false если нет

                    // let text = 'Привет';
                    // console.log(text.includes('рив'));    консоль: true
                    // console.log(text.includes('рив', 3)); консоль: false

    // Методы starWith и endsWith ищут подстроку необходимую или в начале строки или в конце

                    // let text = 'Привет';
                    // console.log(text.starWith('рив')); консоль: false
                    // console.log(text.endsWith('!'));   консоль: true

    // Регистр имеет значение (большой или маленикий символ)

                    // let text = 'Привет';
                    // let searchText = "пР";

                    // console.log(text.toLowerCase().includes(searchText.toLowerCase())); консоль: true 
                    //             сначала мы text переводим в нижний регистр потом с помощью includes ищем совпадения
                    //             при этом searchText тоже переводим в нижний регистр с помощью toLowerCase

    // Метод slise (start, [, end]) - возвращает часть строки от start до end (не включая)

                    // let text = 'Привет';

                    // console.log(text.slice(1, 2)); консоль: p начинаем искать с буквы Р (1 позиция) до буквы и (2 позиция, не включая вторую позицию)
                    // console.log(text.slice(-2, -1)); консоль: е ищем начиная с конца строки
                    // console.log(text.slice(1));      консоль: ривет ищем начиная с 1 позиции

    // Сравнение строк

            // Алгоритм сравнения строк:

            // 1) сначала сравниваються первые символы строк
            // 2) если первый символ первой строки больше(меньше),
            //    чем первый символ второй, то первая строка 
            //    больше(меньше) второй. Сравнение завершено
            // 3) если первые символы равны, то таким же образом 
            //    сравниваються уже вторые символы строк
            // 4) сравнение продолжается пока не закончаться одна изи строк
            // 5) если обе строки заканчиваються одновременно, то они равны,
            //    иначе, большей считается более длинная строка

        // алфавитный порядок 

        //   console.log('A' > 'Б'); консоль: false так как Б больше А в алфавите Б идет второй

        //   console.log('а' > 'Б'); консоль: true потопучто нижний регистр всегда больше верхнего регистра

        //   console.log('Скрипт' > 'Скрипка'); консоль: true 

        // количество символов

            // console.log('Слайдер' > 'Слайд'); консоль: true 

        // регистр

            // console.log('Привет' > 'привет'); консоль: false

    Метод trim() -  удаляет пробельные символы с начала и конца строки. Пробельными символами в этом контексте
                    считаются все собственно пробельные символы (пробел, табуляция, неразрывный пробел и прочие)
                    и все символы конца строки (LF, CR и прочие).

                function rememberMyFilms() {
                    for (let i = 0; i < 2; i++) {
                        const a = prompt('Один из последних просмотренных фильмов?', '').trim,  
                              b = prompt('На сколько оцените его?', '');

                        if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
                                personalMovieDB.movies[a] = b;
                                console.log('done');
                        } else {
                              console.log('arror');
                              i--;
                        }
                    }
                }

                rememberMyFilms();









/* Задание на урок:

1) Первую часть задания повторить по уроку

2) Создать функцию showMyDB, которая будет проверять свойство privat. Если стоит в позиции
false - выводит в консоль главный объект программы

3) Создать функцию writeYourGenres в которой пользователь будет 3 раза отвечать на вопрос 
"Ваш любимый жанр под номером ${номер по порядку}". Каждый ответ записывается в массив данных
genres

P.S. Функции вызывать не обязательно*/


// 'use strict';

// let numberOfFilms;

// function star() {
//     numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

//     while (numberOfFilms == ' ' || numberOfFilms == null || isNaN(numberOfFilms)) {
//         numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');
//     }
// }

// star();

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// function rememberMyFilms() {
//     for (let i = 0; i < 2; i++) {
//         const a = prompt('Один из последних просмотренных фильмов?', '').trim,  
//               b = prompt('На сколько оцените его?', '');
        
//         if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
//                 personalMovieDB.movies[a] = b;
//                 console.log('done');
//         } else {
//               console.log('arror');
//               i--;
//         }
//     }
// }

// rememberMyFilms();

// function detectPersonalLevel() {
//     if (personalMovieDB.count < 10) {
//       console.log('Просмотрено довольно мало фильмов');
//     } else if (personalMovieDB.count >= 10 && personalMovieDB.count < 30) {
//       console.log('Вы классический зритель!');
//     } else if (personalMovieDB.count >= 30) {
//       console.log('Вы киноман))))');
//     } else {
//       console.log('Произошла ошибка');
//     }
// }

// detectPersonalLevel();

// function showMyDB(hidden) {   hidden - скрытый , также можно обозвать и по другому
//     if(!hidden) {
//         console.log(personalMovieDB);
//     }
// }

// showMyDB(personalMovieDB.privat);

// function writeYourGenres() {
//     for (let i = 1; i <= 3; i++) {
//         const a = prompt(`Ваш любимый жанр под номером ${i}`);

//         personalMovieDB.genres[i - 1] = a;
//     }
// }

// writeYourGenres();





      
// Задачи:

// 1) Создайте функцию, которая будет вычислять объем и площадь полной поверхности куба 
// (тоже базовая математика, иногда используется в создании анимаций). Эта функция принимает в себя целое
//  число со значением длины ребра куба. Ответ выведите в формате строки, который изображен в примерах.

// Если в функцию попал неправильный аргумент или вычислить значения невозможно - вернуть строку 
// "При вычислении произошла ошибка"

// Примеры:

// calculateVolumeAndArea(5)  => 'Объем куба: 125, площадь всей поверхности: 150'

// calculateVolumeAndArea(15)  => 'Объем куба: 3375, площадь всей поверхности: 1350'

// calculateVolumeAndArea(15.5)  => 'При вычислении произошла ошибка'

// calculateVolumeAndArea('15')  => 'При вычислении произошла ошибка'

// calculateVolumeAndArea(-15)  => 'При вычислении произошла ошибка'


// function calculateVolumeAndArea (length) {
//     if (typeof(length) !== 'number' || length < 0 || !typeof(length)) {
//        console.log('При вычислении произошла ошибка');
//        return;
//     }

//  let cubeVolume = 0,
//      cubeArea = 0;

//     cubeVolume = length * length * length;
//     cubeArea = 6 *  (length *length);

//     console.log(`Объем куба: ${cubeVolume}, площадь всей поверхности:${cubeArea}`);
// }

// calculateVolumeAndArea('5');






// 2) Напишите функцию, которая будет определять номер купе по переданному ей номеру места.

// Функция принимает только целое число от 1 до 36.

// Если переданный аргумент не число, отрицательное или дробное - возвращается сообщение:

// "Ошибка. Проверьте правильность введенного номера места"

// Если число 0 или больше 36, то сообщение: "Таких мест в вагоне не существует"

// Пример:

// getCoupeNumber(33)  => 9

// getCoupeNumber(7)  => 2

// getCoupeNumber(300)  => "Таких мест в вагоне не существует"

// getCoupeNumber(0)  => "Таких мест в вагоне не существует"

// getCoupeNumber(7.7)  => "Ошибка. Проверьте правильность введенного номера места"

// getCoupeNumber(-10)  => "Ошибка. Проверьте правильность введенного номера места"

// getCoupeNumber('Hello')  => "Ошибка. Проверьте правильность введенного номера места"

// Такая функция вполне реальна и может использоваться для формирования билетов, в том числе и визуально на сайтах. 
// Конечно, там будет куда больше условий, но смысл остается таким ж




// function getCoupeNumber(placeNumber) {
//     if (typeof(placeNumber) !== 'number' || placeNumber < 0 || !Number.isInteger(placeNumber)) {
//         console.log('Ошибка. Проверьте правильность введенного номера места');
//         return;
//     } 
//     if (placeNumber === 0 || placeNumber > 36) {
//         console.log('Таких мест в вагоне не существует');
//         return;
//     } 
//     if (placeNumber === 1 || placeNumber <= 36) {
//         console.log(Math.ceil(placeNumber / 4));
//         return;
//     }
// }

// getCoupeNumber (25);





// Задачи:

// 1) Создайте функцию, которая принимает в себя целое число минут и возвращает время в нужном формате строки. 
// (Смотри пример). Обратите внимание на окончание слова "час" - оно меняется в зависимости от цифры. 
// Если вместо аргумента приходит не число, дробное или отрицательное число - 
// функция возвращает строку "Ошибка, проверьте данные"

// Внимание! Давайте пока ограничимся максимум 600ю минутами (10 часов). Так как проверки на большие числа будут 
// раздувать код (33 часа, 31 час, 11 часов и тд). Этого будет достаточно и код будет проверять 
// именно этот промежуток (1 - 10 часов). Но вы можете реализовать и полный скрипт, он тоже должен проходить тесты.

// Пример:

// getTimeFromMinutes(150) => "Это 2 часа и 30 минут"

// getTimeFromMinutes(50) => "Это 0 часов и 50 минут"

// getTimeFromMinutes(0) => "Это 0 часов и 0 минут"

// getTimeFromMinutes(-150) => "Ошибка, проверьте данные"



        // function getTimeFromMinutes(numberOfMinutes) {
        //     if(typeof(numberOfMinutes) !== 'number' || numberOfMinutes < 0 || !Number.isInteger(numberOfMinutes)) {
        //         console.log('Ошибка, проверьте данные');
        //         return 'Ошибка, проверьте данные';
        //     }
        
        // let hours = Number.parseInt(numberOfMinutes / 60);
        // let minutes = numberOfMinutes % 60;
        
        // let strHours = '';

        // if(hours === 0){
        //     strHours = 'часов';
        // }else if(hours === 1){
        //     strHours = 'час';
        // }else if(hours === 2 || hours === 3 || hours === 4){
        //     strHours = 'часа';
        // }else{
        //     strHours = 'часов'; 
        // }
        // console.log(`Это ${hours} ${strHours} и ${minutes} минут`);
        // return `Это ${hours} ${strHours} и ${minutes} минут`;
        // }

        // getTimeFromMinutes(81);


        

        // function getTimeFromMinutes(minutesTotal) {
        //     if (typeof(minutesTotal) !== 'number' || minutesTotal < 0 || !Number.isInteger(minutesTotal)) {

        //         return "Ошибка, проверьте данные";
        //     }
        
        //     const hours = Math.floor(minutesTotal / 60);
        //     const minutes = minutesTotal % 60;
        
        //     let hoursStr = '';
        
        //     switch (hours) {
        //         case 0: 
        //             hoursStr = 'часов';
        //             break;
        //         case 1:
        //             hoursStr = 'час';
        //             break;
        //         case 2:
        //         case 3:
        //         case 4:
        //             hoursStr = 'часа';
        //             break;
        //         default:
        //             hoursStr = 'часов';
        //     }
        //             return `Это ${hours} ${hoursStr} и ${minutes} минут`;
        // }
        // console.log(getTimeFromMinutes(150) === 'Это 2 часа и 30 минут');
        // getTimeFromMinutes(81);


// 2) Напишите функцию, которая принимает в себя 4 числа и возвращает самое большее из них. Если один из аргументов не 
// является числом или их меньше 4 - возвращается 0. Дробные числа разрешены.

// Пример:

// findMaxNumber(1, 5, 6.6, 11); =>  11

// findMaxNumber(1, 5, '6', '10');  =>  0


// function findMaxNumber(numOne, numTwo, numThree, numFour) {
//     if (typeof(numOne) !== 'number' || typeof(numTwo) !== 'number' || typeof(numThree) !== 'number' || typeof(numFour) !== 'number') {
//         // console.log(0);
//         return 0;
//     } else {
//         // console.log(Math.max(numOne, numTwo, numThree, numFour));
//         return Math.max(numOne, numTwo, numThree, numFour);
//     }
// }

//     findMaxNumber(2, 5.5, 4, 78);
//     findMaxNumber(2, '5.5', 4, 78);
//     findMaxNumber(2, 5.5, 4);



// Задача:

// Создайте функцию, которая будет принимать в себя один аргумент-целое положительное число. Она должна возвращать строку, 
// в которой будут через пробел выведены числа Фибоначчи. Причем, их количество должно быть равно переданному аргументу.

// Если переданный аргумент не число - вернуть пустую строку. Решать без применения рекурсии.

// Пример:

// fib(4) => ''0 1 1 2"

// fib(7) => ''0 1 1 2 3 5 8"

// fib('7') => ''"

// fib(1) => "0"

// fib(0) => ''"



// function fib(numFibo) {
//     if (typeof(numFibo) !== 'number' || numFibo <= 0 || !Number.isInteger(numFibo)) {
//         return "";
//     }

//     let resultFibo = '';
//     let nextNum = 0;
//     let prevNum = 1;

//     for (let i = 0; i < numFibo; i++) {
//         if (i + 1 === numFibo) {
//             resultFibo += `${nextNum}`;
//         } else {
//             resultFibo += `${nextNum} `;
//         }

//         let resNum = nextNum + prevNum;
//         nextNum = prevNum;
//         prevNum = resNum;
//     }

//     return resultFibo;
// }
// console.log(fib(5));

// fib(5);



// const fib = n => {
//     let prev = 0, next = 1;
//     for(let i = 0; i < n; i++){
//       let temp = next;
//       next = prev + next;
//       prev = temp;
//     }
//     return prev;
//   };




// function fibonacci(n) {
//     if(typeof n !== 'number' || n < 0) {
//       return 'Error';
//     }
//     else if(n <= 1) {
//       return n;
//     }
//     else {
//       return fibonacci(n - 1) + fibonacci(n - 2);
//     }
//   }
  
//   console.log(fibonacci(6));


//   Как вывести последовательность чисел Фибоначчи используя рекурсию
//   function fibi(total, i0, i1, index) { 
//     if (! i0) {
//       i0 = 1;
//       index = 1;
//     } else if (! i1) {
//       i1 = 1;
//       index = 2;
//     } else {
//       [i0, i1] = [i0 + i1, i0];
//       index++;
//     }
  
//     console.log(i0);
//     if (index < total) return fibi(total, i0, i1, index);
//   }

//   fibi(5);


// вывод числел по порядку
// function numberOutput(n) {
//     return n ? numberOutput(n - 1) + n.toString() : "";
//   }
//   console.log(numberOutput(9));


// function fib(numFibo) {
// let a = 1;
// let b = 1;
// for(let i = 3; i <= numFibo; i++){
//     let c = a + b;
//     a = b;
//     b = c;

//     // или короткая запись

//     // [a, b] = [b, a + b];
// }

// return b;
// }

// console.log(fib(10));
















                                                    // ОБЬЕКТЫ

            // let userInfo = new Object(); синтаксис  'конструктор обьекта'
            // let userInfo = {};  синтаксис 'литерал обьекта'

    // Свойства обьекта

                // let userInfo = {
                    // name: 'Вася',    ключ (интедефикатор или имя свойства обьекта) name значение Вася
                    // age: 30,         последняя (висячая) запятая
                // };
                // 
                // console.log(userInfo);
                // console.log(userInfo.name)


    // Имена (ключи) свойств объектов

                // let userInfo = {
                    // name: 'Вася',
                    // age: 30,
                    // 'likes javascript': true,
                // };
                // console.log(userInfo.name);      консоль Вася
                // console.log(userInfo['name']);   консоль Вася
                // console.log(userInfo['likes javascript']); консоль true

        // вычисляем имя свойства

                // let firstPart = 'likes';
                // let userInfo = {
                    // name: 'Вася',
                    // age: 30,
                    // [firstPart + ' javascript']: true,
                // };
                // console.log(userInfo['likes javascript']);  консоль true

        // передаем имя свойства

                // let firstPart = 'likes';
                // let userInfo = {
                    // name: 'Вася',
                    // age: 30,
                    // [firstPart]: true,
                // };
                // console.log(userInfo[firstPart]);  консоль true

        // преимущество квадратных скобок

                // let firstPart = 'likes';
                // let userInfo = {
                    // name: 'Вася',
                    // age: 30,
                    // [firstPart]: true,
                // };
                // console.log(userInfo[firstPart]);  консоль true

                // let key = 'name';
                // console.log(userInfo[key]);  консоль Вася
                // console.log(userInfo.key);  если записать через точку то мы получим undefined
                                        //     мы не сможем получить 'Вася' такого имени в этом 
                                        //     обьекте не существует

        // Зарезервированые слова

            // Имена переменных мы не можем использовать специальные
            // зарезервированные слова типа let, for, if и тд
            // имена свойств в нутри обьекта не поддаються этому правилу

                // let firstPart = 'likes';
                // let userInfo = {
                //     let: 'Вася',  здесь можно указывать зарезервированные слова
                //     for: 30         и все будет работать
                // };
                // console.log(userInfo.let); консоль Вася
                // console.log(userInfo.for); консоль 30

            // В качестве имени свойства может быть либо строка либо символ

                // let userInfo = {
                //     0: 'Вася',    это строка ноль
                // };
                // console.log(userInfo[0]);    консоль Вася
                // console.log(userInfo['0']);  консоль Вася


    // Тип данных Symbol

        // Symbol это отдельный тип данных и предстваляет собой уникальный индетификатор

            // Основное пременение символов:
            // 1. 'Скрытые' свойства обьектов
            //     Символьные свойства не появятся в циклах for....in
            // 2. Использование системных символов
            //    Symbol.iterator, Symbol.toPrimitive и тд

                // let id = Symbol('id');
                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     [id]: 'Какоето значение',
                // };
                // console.log(userInfo);    консоль { name: 'Вася', age: 30, [Symbol(id)]: 'Какоето значение' }


    // Вложенность объектов

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address:{
                //         city: 'Kharkiv',
                //         street: 'Myra',
                //     } 
                // };
                // console.log(userInfo);      консоль { name: 'Вася', age: 30, address: { city: 'Kharkiv', street: 'Myra' } }
                // console.log(userInfo.address); консоль { city: 'Kharkiv', street: 'Myra' }
                // console.log(userInfo.address.city); консоль Kharkiv


    // Значение свойств объекта из переменных

                // function makeUserInfo(name, age) {
                //     return {             функция возвращает обьект с именами свойтва
                //         name: name,
                //         age: age,
                //         // другие свойства
                //     };
                // }
                // let user = makeUserInfo('Вася', 30);            создаем переменную со свойствами 
                // console.log(user);    консоль { name: 'Вася', age: 30 }    и передаем значение в функцию

            // или можно записать так
                
                // function makeUserInfo(name, age) {
                //     return { 
                //         name,  // тоже самое  что name: name,
                //         age,    //тоже самое что age: age,
                //         'likes javascript': true,
                //         // другие свойства
                //     };
                // }
                // let user = makeUserInfo('Вася', 30);
                // console.log(user);    консоль { name: 'Вася', age: 30, 'likes javascript': true }


    // Изменение объекта и его свойств

        // добавление свойств

                // let userInfo = {
                //     name: 'Вася',
                // };
                // console.log(userInfo);   консоль  { name: 'Вася' }
                // добавляем новое значение возвраст
                // userInfo.age = 30;

                // console.log(userInfo);   консоль { name: 'Вася', age: 30 }  появляетьс ятеперь два свойства

                // userInfo['likes javascript'] = true;

                // console.log(userInfo);   консоль  { name: 'Вася', age: 30, 'likes javascript': true }

                // userInfo.address = {     добавляем обьект внутрь обьекта
                //     city: 'Kharkiv',
                //     street: 'Myra',
                // };
                // console.log(userInfo);   консоль   {
                //                                       name: 'Вася',
                //                                       age: 30,
                //                                       'likes javascript': true,
                //                                       address: { city: 'Kharkiv', street: 'Myra' }
                //                                     }

        // удаление свойств

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     'likes javascript': true,
                // };
                // console.log(userInfo);   консоль { name: 'Вася', age: 30, 'likes javascript': true }

                // delete userInfo.age;
                // console.log(userInfo);   консоль { name: 'Вася', 'likes javascript': true }

                // delete userInfo['likes javascript'];
                // console.log(userInfo);   консоль { name: 'Вася' }

        // Изменение значения в каком нибудь свойстве

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                // };
                // console.log(userInfo);  консоль { name: 'Вася', age: 30 }

                // userInfo.age = 18;
                // console.log(userInfo);  консоль { name: 'Вася', age: 18 }

            // изменять значение имени свойства можно даже в константе

                // const userInfo = {
                //     name: 'Вася', 
                //     age: 30,
                // };
                // console.log(userInfo);  консоль { name: 'Вася', age: 30 }

                // userInfo.age = 18;
                // console.log(userInfo);  консоль { name: 'Вася', age: 18 }

        // Копировние обьектов

            // При копировании обьекта в другую переменную сам обьект
            // не дублируется, а копируется только ссылка на него

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                // };
                // console.log(userInfo);  консоль { name: 'Вася', age: 30 }

                // let user = userInfo;
                // console.log(user);      консоль { name: 'Вася', age: 30 }

                // user.age = 18;
                // console.log(userInfo);  консоль { name: 'Вася', age: 18 }


                    // const obj = {
                    //     a: 5,
                    //     b: 1,
                    // };

                    // const copy = obj; происходит передача значения по ссылке тоесть идет ссылка на obj

                    // copy.a = 10; изменяя что-то в copy мы изменяем изначальгный обьект

                    // console.log(copy);   { a: 10, b: 1 }
                    // console.log(obj);    { a: 10, b: 1 }

            // с примитивными типами данных  типа строки, числа логические значения они передаються по значению
            // когда работаем с обьектами то передача идет по ссылке


                    // function copy(mainObj) {
                    //     let objCopy = {};
                    //     let key;
                    //     for (key in mainObj) {
                    //         objCopy[key] = mainObj[key];
                    //     }
                    //     return objCopy;
                    // }

                    // const numbers = {
                    //     a: 2, 
                    //     b: 5,
                    //     c: {
                    //         x: 7,
                    //         y: 4,
                    //     }
                    // };
                    // const newNumbers = copy(numbers);

                    // newNumbers.a = 10;
                    // console.log(newNumbers);  // { a: 10, b: 5, c: { x: 7, y: 4 } }
                    // console.log(numbers);    { a: 2, b: 5, c: { x: 7, y: 4 } }




        // Дублирование обьекта

            // для дублирования обьекта удобно использовать (Object.assign)
            // Object.assign(куда(обьект), что(свойство№1), что(свойство№2),...);

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                // };

                // let user = Object.assign({}, userInfo); создаем новыю переменную дальше Object.assign 
                //                                         в нем создаем новый пустой обьект {} и дальше 
                //                                         указываем откуда будем копировать userInfo
                // // user.age = 18;    в новом значении user меняем одно из значений age

                // console.log(userInfo); консоль { name: 'Вася', age: 30 } тут значения не поменялись
                // console.log(user);     консоль { name: 'Вася', age: 18 } в новом обьекте значения поменялись

            // также с помощью Object.assign можем добавлять новые свойства в обьект

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                // };

                // Object.assign(userInfo, {['likes javascript']: true, city: 'Kharkiv'});
                // console.log(userInfo); консоль { name: 'Вася', age: 30, 'likes javascript': true, city: 'Kharkiv' }


    // Проверка существования свойства объекта

                // let userInfo = {
                //     name: 'Вася',
                //     //age: 30,
                // };
                // console.log(userInfo.age); //консоль 30
                // console.log(userInfo.age); если убрать одно из свойств (например age)то получим undefined
                // проверка свойства
                // if(userInfo.age) {      если будет  undefined то вернется false
                    // console.log(userInfo.age);  если значние будет существовать то вернется true
                // }                                и мы выведем его в консоль
                // 

        // Опциональная цепочка еще один из методов проверки

            // Опциональная цепочка ?. — это безопасный способ доступа к свойствам вложенных объектов, 
                                    // даже если какое-либо из промежуточных свойств не существует.

            // Опциональная цепочка ?. останавливает вычисление и возвращает undefined,
            //  если значение перед ?. равно undefined или null.

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address: {     
                //         city: 'Kharkiv',
                //         street: 'Myra',  
                //     }
                // };
                // console.log(userInfo.address.street); У большинства наших пользователей есть адреса в свойстве user.address
                // или console.log(userInfo['address']['street']);    с улицей user.address.street, но некоторые из них их не указали.
                                                    // В таком случае, когда мы попытаемся получить user.address.street, 
                                                    // а пользователь окажется без адреса, мы получим ошибку:
                                                    // В таком случае, когда мы попытаемся получить user.address.street, 
                                                    // а пользователь окажется без адреса, мы получим ошибку:
                // console.log(userInfo?.address?.street);  пользователь без адреса но мы получаем undefined (без ошибки)
             
        // Оператор in

                // Когда свойство существует, но содержит значение undefined то следует использовать 'in'

                // let userInfo = {
                //         name: undefined,

                // };
                // if(userInfo.name) {   //такая запись (  name: undefined,) вернет false
                //     console.log(userInfo.name);
                // }

                // if('name' in userInfo) {  // при такой проверки значение сработает и вернет true
                //     console.log(userInfo.name); консоль undefined
                // }

    // Цикл for in

        // производит обход объектов. Обход перечисляемых свойств объекта осуществляется в произвольном порядке.

        // Для for...of обход происходит в соответствии с тем, какой порядок определён в итерируемом объекте


            // for (let a in object) { let а - переменная которая содержит имена свойств object это обьект
                // тело цикла, выполняется для каждого свойства обьекта
            // }

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address: {     
                //         city: 'Kharkiv',
                //         street: 'Myra',  
                //     }
                // };
                // for (let key in userInfo) {
                //     // ключи
                //     console.log(key); консоль name, age, address
                //     // значение ключей
                //     console.log(userInfo[key]); консоль Вася, 30, Object{}
                // }

                // for (let key in userInfo.address) {
                //     // ключи
                //     console.log(key);  консоль city, street
                //     // значение ключей
                //     console.log(userInfo[key]); консоль Kharkiv, Myra
                // }

                // const option = {
                //     name: 'test',
                //     with: 1024,
                //     height: 60,
                //     colors: {
                //         border: 'black',
                //         bg: 'red',
                //     }
                // };

                // for (let key in option) {
                //     if (typeof(option[key]) === 'object') {
                //         for (let i in option[key]) {
                //             console.log(`Свойство ${i} имеет значение ${option[key][i]}`);
                //         }
                //     } else {
                //         console.log(`Свойство ${key} имеет значение ${option[key]}`);
                //     }
                // }


    // Методы объектов. Использование "this"

                // let userInfo = {
                    // name: 'Вася',
                    // age: 30,
                    // address: {     
                        // city: 'Kharkiv',
                        // street: 'Myra',  
                    // },
                    // showInfo: function() {
                        // console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, улица ${userInfo.address.street}.`);
                    // }
                    // 
                // более короткая запись
                    // showInfo() {
                        // console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, улица ${userInfo.address.street}.`);
                    // }
                // };
                // userInfo.showInfo();

            // использрование this



                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address: {     
                //         city: 'Kharkiv',
                //         street: 'Myra',  
                //     },
                //     showInfo() { с такой записью функции this не будет работать, будет ошибка
                //         // console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, улица ${userInfo.address.street}.`);
                //         
                // а со стрелочной функцией будет работать так как нет вложеностей и this обращается к родительский обьект let userInfo = {,,,,,,
                //          вместо userInfo мы пишем просто this это будет предпологать текущий обьект
                //         console.log(`${this.name}, ${this.age} лет. Адрес: г.${this.address.city}, улица ${this.address.street}.`);
                //     }
                // };
                // userInfo.showInfo();



                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address: {     
                //         city: 'Kharkiv',
                //         street: 'Myra',  
                //     },
                //     showInfo() {
                    // function show() {
                    //     console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, улица ${userInfo.address.street}.`);
                    // }
                    // у стрелочной функции нет своего "this" используется значение
                    // из фвнешнего метода userInfo.userInfo()
                    // let show = () => console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: 
                    // г.${userInfo.address.city}, 
                    // улица ${userInfo.address.street}.`);
                //     show();
                //     }
                // };
                // userInfo.showInfo();

            // Использование this намного надежнее чем использование имени переменной

                // let userInfo = {
                //     name: 'Вася',
                //     age: 30,
                //     address: {     
                //         city: 'Kharkiv',
                //         street: 'Myra',  
                //     },
                //     showInfo() {
                //         console.log(`${userInfo.name}, ${userInfo.age} лет. Адрес: г.${userInfo.address.city}, улица ${userInfo.address.street}.`);
                //     }
                // };
                // userInfo.showInfo();

                // let user = userInfo; передаем значение в новую переменную
                // userInfo = null;     старую переменную обнуляем 
                // user.showInfo();     тогда в консоли когда попытаемся вызвать новую переменную будет ошибка
                //         но еслибы была выше запись вместо userInfo поставили this
                //         showInfo() {
                //             console.log(`${this.name}, ${this.age} лет. Адрес: г.${this.address.city}, улица ${this.address.street}.`);
                //         } 
                //         };
                //         userInfo.showInfo();
                //         let user = userInfo;
                //         user.showInfo(); 
                //         user.showInfo();  то здесь бы уже ошибки небыло и работало потомучто нет 
                //                           привязки к конкретному обьекту


        // метод keys() -  возвращает массив из собственных перечисляемых свойств переданного объекта, в том же порядке,
                        //  в котором они бы обходились циклом for...in (разница между циклом и методом в том, что цикл 
                            // перечисляет свойства и из цепочки прототипов)

                // const option = {
                //     name: 'test',
                //     with: 1024,
                //     height: 60,
                //     colors: {
                //         border: 'black',
                //         bg: 'red',
                //     }
                // };

                // console.log(Object.keys(option));  консоль [ 'name', 'with', 'height', 'colors' ]
                // console.log(Object.keys(option).length);  консоль 4  количество элементов в массиве   

               
        // Содание метода самостоятельно

                // const option = {
                //     name: 'test',
                //     with: 1024,
                //     height: 60,
                //     colors: {
                //         border: 'black',
                //         bg: 'red',
                //     },
                //     makeTest: function() {  создали метод 
                //         console.log('Nest');
                //     }
                // };

                // option.makeTest();

    // Функции-конструкторы

            // Обычный синтаксис создания обьекта{...} позволяет создать только один обьект.обьект
            // Но зачастую нам нужно создать множество однотипных обьектов, таких пользователи, элементы меню и тогда
            // это можно сделать при помощи функции - конструктора и оператора 'new'

            // Функции-конструкторы являються обычными функциями
            // но есть два правила:
            // 1. Имя функции конструктора должно начинаться с большой буквы
            // 2. Функции-конструктор должна вызываться при помощиоператора 'new'

                    // function UserInfo(name) {
                        //сначало
                         //this = {}; создается пустой обьект (неявно)
                    
                        // this.name = name;
                        // this.age = 30;
                        //потом будет автомтически возвращать в return
                        //return this; возвращает обьект не явно
                        
                        // return можно писать и возвращать то что надо а не автомвтически
                    // }
                    // console.log(new UserInfo('Вася'));
                    // console.log(new UserInfo('Лена'));







//Задачи:
// 1) Напишите функцию showExperience, которая будет принимать в себя объект со
//  всеми данными и возвращать строку с опытом.

// Пример:

// showExperience(personalPlanPeter) => '1 month'

// P.S. желательно использовать деструктуризацию, но не обязательно


// const personalPlanPeter = {
//     name: "Peter",
//     age: "29",
//     skills: {
//         languages: ['ru', 'eng'],
//         programmingLangs: {
//             js: '20%',
//             php: '10%'
//         },
//         exp: '1 month'
//     }
// };

// function showExperience(plan) {

//    const {exp} = plan.skills; 
//    console.log(exp);
//     return exp;
// }

// showExperience(personalPlanPeter);



// 2) Напишите функцию showProgrammingLangs, которая будет принимать в себя объект со 
// всеми данными и возвращать строку в нужном виде.

// Пример:

// showProgrammingLangs(personalPlanPeter)  =>

// "Язык js изучен на 20% Язык php изучен на 10%"

// Причем функция должна работать вне зависимости от количества языков. Если ни 
// один не указан, то возвращается пустая строка.

// P.S. Для переноса строки используется \n в конце строки.



// function showProgrammingLangs(plan) {

//     let str = '';
//     const {programmingLangs} = plan.skills;
//     for (let key in programmingLangs) {
//         str += `Язык ${key} изучен на ${programmingLangs[key]}\n`;
//     }
// console.log(str);
// return str;

// }

// showProgrammingLangs(personalPlanPeter);





// 3) Создайте метод showAgeAndLangs внутри объекта personalPlanPeter. При его вызове
//  метод будет принимать в себя объект и возвращать строку в нужном виде.

// Пример:

//     personalPlanPeter.showAgeAndLangs(personalPlanPeter)

// => 'Мне 29 и я владею языками: RU ENG'

// Заметьте, что возраст и языки подставляются автоматически из объекта, а языки всегда в
//  верхнем регистре (большими буквами). Если данные в объекте поменяются, то и сообщение
//   тоже измени

// const personalPlanPeter = {
//     name: "Peter",
//     age: "29",
//     skills: {
//         languages: ['ru', 'eng'],
//         programmingLangs: {
//             js: '20%',
//             php: '10%'
//         },
//         exp: '1 month'
//     }
// // третье решение нужно вставить сюда

// showAgeAndLangs: function(plan) {
//     const {age} = plan;
//     const {languages} = plan.skills;
//     let str = `Мне ${age} и я владею языками: `;

//     languages.forEach(function(lang) {
//         str += `${lang.toUpperCase()} `;
//     });

//     return str;
// }
// };

// personalPlanPeter.showAgeAndLangs(personalPlanPeter);




// Задачи:

// 1) Напишите функцию showFamily, которая будет принимать в себя массив строк и
//  возвращать сообщение в нужном формате.

// showFamily(family)  => 'Семья состоит из: Peter Ann Alex Linda'

// Имена подставляются автоматически из массива. Если массив пустой, то выводится 
// сообщение 'Семья пуста'


// const family = ['Peter', 'Ann', 'Alex', 'Linda'];

// function showFamily(arr) {

//     let str = ' ';
       
//       if(arr.length === 0) {
//           str = `Семья пуста `;
//       } else {
//           str = `Семья состоит из:  `;
//       
//             или
//       arr.length === 0 ? str = 'Семья пуста' : str = 'Семья состоит из: ';

//       arr.forEach(function(num) {
//           str += `${num} `;
//       });
//     // return str;
//     console.log(str);

// }

// showFamily(family);

// 2) напишите функцию standardizeStrings, которая будет принимать в себя массив строк и будет выводить в консоль
//  эти строки в нижнем регистре.

// Пример:

// standardizeStrings(favoriteCities)  выведет в консоль

//     lisbon
//     rome
//     milan
//     dublin

// Это частая задача в реальности, так как от пользователя нам могут прийти ответы в самых разных форматах. В том числе
//  и с разными буквами :) Поэтому нам нужно привести строки в один формат для правильной работы.




// const favoriteCities = ['liSBon', 'ROME', 'miLan', 'Dublin'];

// function standardizeStrings(arr) {
//     arr.forEach(function(str) {
//         console.log(str.toLowerCase());
//     });

//     //или

//     // arr.forEach(str => {
//     //     console.log(str.toLowerCase());

//     // });

// }

// standardizeStrings(favoriteCities);



// 3) Задача с собеседований. Напишите функцию reverse, которая принимает в себя строку и возвращает эту строку
//  в обратном порядке.

// Пример:

//     const someString = 'This is some strange string';

// reverse(someString) => 'gnirts egnarts emos si sihT'

// Функцию можно применить к любой строке. Если в функцию приходит не строка - вернуть сообщение "Ошибка!"

// Это очень интересная задача, которую можно решить несколькими способами. Её дают для того, чтобы оценить навык
//  и знания программиста, посмотреть как он думает. Как небольшая подсказка, есть метод, который может вам помочь. 
//  И часть дополнительных вариантов решения мы тоже изучим в течении курса.

// Может показать сложной с первого взгляда, но это совсем не так 🙂

// const someString = 'This is some strange string';

// function reverse(str) {

//     if (typeof(str) !== 'string') {
//         // return 'Ошибка!';
//         console.log('Ошибка!');
//     } else{
//         // return str.split('').reverse().join('');
//         console.log(str.split('').reverse().join(''));
//     }

//     // или

//      // let newStr = '';
//     // for (let i = str.length - 1; i >= 0; i--) {
//     //     newStr += str[i];
//     // }
//     // return newStr;
// }

// reverse(someString);






// 4) Представьте такую реальную ситуацию. У вас есть банкомат, который выдает деньги из двух разных банков в разных
//  валютах. Один банк основной с базовыми валютами, второй дополнительный с прочими валютами:

//     const baseCurrencies = ['USD', 'EUR'];
//     const additionalCurrencies = ['UAH', 'RUB', 'CNY'];

// Вам нужно создать главную функцию банкомата availableCurr, которая принимает два аргумента: первый - это массив со
//  всеми доступными валютами из двух банков сразу (сейчас представим, что они не могут повторяться), второй - необязательный
//   аргумент, который указывает ту валюту, которая сейчас закончилась в банкомате. Если массив в первом аргументе пустой - то
//    функция возвращает строку 'Нет доступных валют'. Функция возвращает строку в нужном виде.

// Пример:

//     availableCurr(['UAH', 'RUB', 'CNY'], 'CNY')

// Вернет строку:

//     Доступные валюты:
//     UAH
//     RUB

// Заметьте:

// - CNY (юань) исчез из списка валют, значит такая валюта закончилась

// - После валюты: стоит перенос строки \n, и после каждой валюты тоже. Это важно для тестов

// - Данные для первого аргумента должны приходить сразу из двух банков, причем сначала baseCurrencies, 
// потом additionalCurrencies по порядку

// const baseCurrencies = ['USD', 'EUR'];
// const additionalCurrencies = ['UAH', 'RUB', 'CNY'];

// function availableCurr(arr, missingCurr) {

//     let str = '';

//     arr.length === 0 ? str = 'Нет доступных валют.' : str = 'Валюты в наличии:\n';

//       arr.forEach(function(a, b) {
//        if(a !== missingCurr){
//             str += `${a}\n`;
//        }
//     });

//      // или

//     // for (let i = 0; i < arr.length; i++) {
//     //     if (arr[i] === missingCurr) {
//     //         continue;
//     //     }
//     //     str += `${arr[i]}\n`;
//     // }

//     // return str;
//     console.log(str);
// }

// availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY');






/* Задание на урок:

1) У нас уже есть рабочее приложение, состоящее из отдельных функций. Представьте, что
перед вами стоит задача переписать его так, чтобы все функции стали методами объекта personalMovieDB
Такое случается в реальных продуктах при смене технологий или подхода к архитектуре программы

2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

3) В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
при помощи метода forEach вывести в консоль сообщения в таком виде:
"Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/

'use strict';

const personalMovieDB = {
    count: 0,
    movies: {},
    actors: {},
    genres: [],
    privat: false,
    star: function () {
        this.count = +prompt('Сколько фильмов вы уже посмотрели?', '');

        while (this.count == ' ' || this.count == null || isNaN(this.count)) {
            this.count = +prompt('Сколько фильмов вы уже посмотрели?', '');
        }
    },

    rememberMyFilms: function () {
        for (let i = 0; i < 2; i++) {
            const a = prompt('Один из последних просмотренных фильмов?', '').trim,  
                  b = prompt('На сколько оцените его?', '');
            
            if (a != null && b != null && a != '' && b != '' && a.length < 50 && b.length < 50) {
                    this.movies[a] = b;
                    console.log('done');
            } else {
                  console.log('arror');
                  i--;
            }
        }
    },

    detectPersonalLevel: function () {
        if (this.count < 10) {
          console.log('Просмотрено довольно мало фильмов');
        } else if (this.count >= 10 && this.count < 30) {
          console.log('Вы классический зритель!');
        } else if (this.count >= 30) {
          console.log('Вы киноман))))');
        } else {
          console.log('Произошла ошибка');
        }
    },

    showMyDB: function (hidden) {   //hidden - скрытый , также можно обозвать и по другому
        if(!hidden) {
            console.log(personalMovieDB);
        }
    },

    
    toggleVisibleMyDB: function(){
        if(this.privat){
            this.privat = false;
        } else{
            this.privat = true;
        }
    },
    
    writeYourGenres: function () {
        for (let i = 1; i <= 3; i++) {
            const a = prompt(`Ваш любимый жанр под номером ${i}`);
        // Проверка на пустое поле для ввода ИЛИ на кнопку Отмена
            if(a === '' || a == null){
                console.log('Вы ввели некорректные данные или не ввели их вовсе');
                i--;
            }
            else{
                personalMovieDB.genres[i - 1] = a;
            }
        }
        // Вывод любимых жанров №... - Метод forEach
        this.genres.forEach((item, i) => {
            console.log(`Любимый жанр ${i + 1} - это ${item}`);
        });
    },
};












// Задача:

// У вас есть небольшой кусочек данных о торговом центре, которые записаны в объекте shoppingMallData. 
// Они содержат массив с данными о магазинах, где указана длина и ширина помещения; высоту помещения;
//  стоимость отопления за 1 кубический метр и бюджет на оплату отопления за месяц.

// Основная задача - это написать функцию isBudgetEnough, которая буде возвращать строку. Если бюджета
//  хватает для отопления всего объема торгового центра - выводится 'Бюджета достаточно', если 
//  нет - 'Бюджета недостаточно'. И все 🙂

// Но эта задача содержит несколько подзадач внутри:

// - вычисление общей площади всех магазинов, которая вычисляется как длина магазина, умноженная на его ширину;

// - вычисление общего объема торгового центра, так как цена отопления указана в кубических метрах;

// - определение того, хватает ли бюджета на оплату такого объема;

// - все числа идут без единиц измерения для упрощения, просто цифры и все;

// - функция должна продолжать работать, даже если изменяется количество магазинов, высота, бюджет или
//  подставляется вообще другой объект.













// Задача:

// У вас есть список учеников, которые хотят поиграть в игру:

//     const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];

// Но команд может быть только 3 по 3 человека. Напишите функцию sortStudentsByGroups, 
// которая принимает в себя массив строк.

// Внутри она сначала сортирует имена по алфавиту. Затем распределяет учеников по 3 человека
//  в 3 группы по алфавитному порядку. Эти группы должны быть массивами. Как итог, функция 
//  возвращает новый массив с тремя командами и строкой как 4й элемент.

// Пример:

// sortStudentsByGroups(students)  =>

//     [
//       [ 'Andrew', 'Ann', 'Bernard' ],
//       [ 'Cris', 'Josh', 'Mark' ],
//       [ 'Peter', 'Sam', 'Sandra' ],
//       'Оставшиеся студенты: Takesi'
//     ]

// Если убрать одно студента из списка, то результат будет:

//     [
//       [ 'Andrew', 'Ann', 'Bernard' ],
//       [ 'Cris', 'Josh', 'Mark' ],
//       [ 'Peter', 'Sam', 'Sandra' ],
//       'Оставшиеся студенты: -'
//     ]

// А если добавить одного, то:

//     [
//       [ 'Andrew', 'Ann', 'Bernard' ],
//       [ 'Cris', 'Josh', 'Mark' ],
//       [ 'Peter', 'Sam', 'Sandra' ],
//       'Оставшиеся студенты: Takesi, Somebody'
//     ]

// То есть, меняется содержимое строки. Все оставшиеся ученики попадают туда.

// Задача интересная, немного заковыристая, но все необходимое для неё мы уже проходили. 
// Просто распишите логику действий строка за строкой.