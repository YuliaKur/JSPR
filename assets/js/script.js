// "use strict"; - современный режим в нем работаяют некоторые неточности которые были в старых версиях JS, прописввается только в начале кода

// a =15;
// console.log(a); 
// так можно было записывать в старых версиях JS


// console.log(1);
// let number = 5;
// const leftBorderWith = 1;

// number =10;
// console.log(number);

// const obj = {
// a:50
// };

// obj.a = 10;
// console.log(obj);

// Названия переменных для const которые нельзя менять и лучше придерживаться такого правила их написания
// например:
// const snake_case
// const UPPER_SNEKE_CASE
// const _api_Base

// Задание 1
// let userName = "John";
// let userNumber = 25;

// userNumber = 24;

// console.log(userName + userNumber);



// ТИПЫ ДАННЫХ  JS

// Простые Типы
// Числа 1,2,3
// Строки "strin", "name"
// Логический тип (boolean)
// true,false
// null
// undefined
// Symbol
// Biglnt

// Обьекты
// Спец. Обьекты:
// Массивы []
// Функции function
// Обьект Даты
// Регулярные выражения
// Ошибки

// Обычные обьекты


// const obj = {
//     name: "John",
//     age: 25,
//     isMarried: false
// };


                                    // МАСИВЫ. Методы

// массив не является отдельным типом данных, они основаны на обьектах




    // Длина массива

// length() - является свойством объекта функции и указывает, сколько аргументов ожидает функция, то есть, количество формальных параметров
            // arr.length ('дима', 'катя');
            // console.log(arr)

    // Работа с очередью и стеком

// push() - добавляет неограниченное количество элементов в конец массива
            // arr.push ('дима', 'катя');
            // console.log(arr)

// shift() - удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива
            // arr.shift ('дима', 'катя');
            // console.log(arr)

// pop() - удаляет последний элемент из массива и возвращает его значение.
            // arr.pop ('дима', 'катя');
            // console.log(arr);

// unshift() - добавляет один или более элементов в начало массива и возвращает новую длину массива
            // arr.unshift ('дима', 'катя');
            // console.log(arr);

    // Редактирование элементов массива        

// splice() -  изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
        // удаляем переменную
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // arrTwo.splice(1, 1);
                // console.log(arrTwo);
        // возвращаем переменную
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // let removed = arrTwo.splice(1, 1);
                // console.log(removed);
        // заменяем один элемент на другой
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // Ваня заменяем на Юля
                // arrTwo.splice(0, 1, 'Юля); ноль это позиция эелемента, 1 количество заменяемых элементов, 'Юля' на что заменяем
                // console.log(arrTwo);
        // добавляем элемент
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // larrTwo.splice(1, 0, 'Маша', 'Юля'); одни означает перед первой позицией, ноль означает что чтото добавляем, 
                                                    //  дальше через запятую указываем элементы которые хотим добавить ('Маша', 'Юля')
                // console.log(arrTwo);
        // удаляем элемент массива
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // начиная с последней позиции (Оля) удаляем один элемент
                // arrTwo.splice(-1, 1); минус одни означает с конца позиция, одни означает что один элемент
                // console.log(arrTwo);

    // Копирование массивов

// slice () - возвращает новый массив, содержащий копию части исходного массива.
                // let arrOne = ['Ваня', 'Коля', 'Оля',]

                // копировать будет начиная с первой позиции (Коля)
                // до второй позиции Оля
                //  let arrTwo = arrOne.slice(1, 2);
                // console.log(arrTwo);

                // начиная с предпоследней позиции Коля, тоесть с права на лево
                // до последней позиции Оля не включая Оля
                //  let arrTwo = arrOne.slice(-2, -1);
                // console.log(arrTwo);

                // Копируем весь массив
                //  let arrTwo = arrOne.slice();
                // console.log(arrTwo);

// concat() - возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого 
                    //с другими массивами и/или значениями, переданными в качестве аргументов
                // let arrOne = ['Ваня', 'Коля', 'Оля',]
                //  let arrTwo = arrOne.concat('Петя'); через заяпятую можно добавить сколько угодно данных
                // console.log(arrTwo); данные добявяться в конце массива

    // Поиск в массиве

// indexOf() - возвращает индекс первого вхождения указанного значения в строковый объект String , 
            // на котором он был вызван, начиная с индекса fromIndex . Возвращает -1, если значение не найдено

                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // console.log(arr.indexOf('Коля'));в круглых скобках пишем то что хотим найти в массиве (Коля)
                // console.log(arr.indexOf('Коля', 2));в круглых скобках пишем то что хотим найти в массиве (Коля)
                //                                      двойка ознаяает что ищем со второй позиции


// lastIndexOf() - возвращает индекс последнего вхождения указанного значения в строковый объект String ,
            //  на котором он был вызван, или -1, если ничего не было найдено. Поиск по строке ведётся от конца к началу, 
            //  начиная с индекса fromIndex .


// includes() - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false .
                // let arrTwo = ['Ваня', 'Коля', 'Оля',]
                // console.log(arr.includes('Коля')); в круглых скобках пишем то что хотим найти в массиве (Коля)
                // console.log(arr.indexOf('Коля', 2));в круглых скобках пишем то что хотим найти в массиве (Коля)
                //                                      двойка ознаяает что ищем со второй позиции

    // Поиск в массиве объектов

// find() - возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции.
//          В противном случае возвращается undefined               
//         если true возвращает текуший элемент и перепор обьектов прекращается
//         если все итерации оказались ложными  возвращается undefined
                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // 
                // let resultOne = arr.find(function(item, index, array) {      item сам элемет массива, index ключ или позиция массива
                    // return item.age === 18;                                  array это весь масив
                // });
                // 
                // или
                // 
                // let resultOne = arr.find(item => item.age === 18);
                // 
                // console.log(resultOne);
                // 

// findIndex() - возвращает индекс (ключ) в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1
                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // let resultOne = arr.findIndex(item => item.age === 18);
                // 
                // console.log(resultOne);


// filter() - создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
            // если true элемент добавляется и перебор продолжается
            // возвращается пустой массив если ничего не найдено

                // let arr = [
                    // {name: 'Вася', age: 36},
                    // {name: 'Коля', age: 18},
                    // {name: 'Оля', age: 'Не скажу'},
                // ]
                // let resultOne = arr.filter((function(item, index, array) {
                //     return item.age >= 18;
                // }
                // console.log(resultOne);

    // Сортировка массива

// sort() - сортирует элементы массива и возвращает отсортированный массив.

        // Сортировка слов
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',]    
        //         console.log(arrTwo.sort());
                    // в консоль выведит сортировку в алфавитном порядке


        // Сортировка чисел
        //         let arrTwo = [8, 22, 1,]    
        //         console.log(arrTwo.sort());

                // функция сортировки
                // function compareNumber (a, b) {
                //     if (a > b) return 1;
                //     if (a == b) return 0;
                //     if (a < b) return -1;

                        // или

                        // return a - b
                // }

                // console.log (arrTwo.sort(compareNumber));

                // или вместо функции сортировки написать вот так

                // console.log (arrTwo.sort((a, b) => a - b)); выведит в консоль такой же массив [1, 8, 22,]


// reverse() - на месте переставляет элементы массива, на котором он был вызван, изменяет массив и возвращает ссылку на него.
            // меняет порядок элементов в масиве на обратный
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',];    
        //         console.log(arrTwo.reverse());  выведит в консоль такой же массив ['Оля', 'Коля', 'Ваня',]

    // Преобразование массива

//  map() - принимает первым параметром функцию. Дальше, внутри себя, map() перебирает элементы переданной коллекции и для каждого
//           элемента вызывает переданную функцию. На вход этой функции передаётся элемент исходного массива, а её результат
//           записывается в новый массив, который и возвращается наружу.
            // вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции
        //         let arrTwo = ['Ваня', 'Коля', 'Оля',]; 
        // let result = arr.  map((function(item, index, array) {   item сам элемет массива, index ключ или позиция массива
        //         return item[0];                                  array это весь масив
        //     });  

        //     или

        // let result = arr.  map(item => item[0]);
        //         console.log(arr);  выведит в консоль такой же массив ['Ваня', 'Коля', 'Оля',]
        //         console.log(result);  выведит в консоль такой же массив ['В', 'К', 'О',] 

// split() - разбивает объект String на массив строк путём разделения строки указанной подстрокой.
//           преобразует строку в массив по заданому разделителю 

              
              
        // let str = 'Ваня, Коля, Оля';
        // let arr = str.split(',');     заданный разделитель (,) можем указать любой разделитель какой нас интересует
        // console.log(arr);             выведит в консоль массив ['Ваня', 'Коля', 'Оля']
        // 
        // 
        // let arrTwo = str.split(',', 2); ограничение в вывод в массив до 2 элементов
        // console.log(arrTwo);            выведит в консоль массив ['Ваня', 'Коля']


        
// join() - объединяет все элементы массива (или массивоподобного объекта) в строкуjoin
         // преобразует массив в строку с заданым разделителем
         
                    //  let arr = ['Ваня', 'Коля', 'Оля',];
                    //  let str = arr.join(',');      заданный разделитель (,) можем указать любой разделитель какой нас интересует
                    //  console.log(arr);             выведит в консоль строку где строка разделена указаным разделителем   (Ваня, Коля, Оля)


                    //  let arrTwo = ['Ваня', 'Коля', 'Оля',];
                    //  console.log(String(arrTwo));   тот же будет результат если мы просто используем метод String
                    //                                 но при методе стринг мы не можем уазать метод разделения и он всегда будет запятая


// Array.isArray() - возвращает true , если объект является массивом и false, если он массивом не является.

                    // let obj = {};
                    // let arr = [];

                    // if (Array.isArray(arr)) {                  в скобках указываем переменную которую хотим понять массив это или нет
                    //     console.log ('Это массив!');           в этом случае значение будет true консаль выдаст 'Это массив!'
                    // } else {
                    //     console.log('Это не массив!');         
                    // }

                    // if (Array.isArray(obj)) {                  
                    //     console.log ('Это массив!');           
                    // } else {
                    //     console.log('Это не массив!');        в этом случае значение будет false консоль выдаст  'Это не массив!'
                    // }

    // Перебор элементов массива

    //                 let arr = ['Ваня', 'Коля', 'Оля',];
    //                 console.log(arr.length);

    // цикл FOR
    //                 можем получить значение и ключ массива


    //                 for (let i = 0; i < arr.length; i++) {
    //                     console.log(arr[i]);                    консоль выведет Ваня Коля Оля
    //                 }

    // цикл FOR...OF
    //                 можно  использовать для вывода значений

    //                 let arr = ['Ваня, Коля, Оля',];
            
    //                        for (let arrItem of arr) {              let arrItem переменная которая будет содержать в себе каждое значение массива
    //                     console.log(arrItem);               консоль выведет Ваня Коля Оля 
    //                 }

    // forEach - выполняет функцию для каждого элемента массива

                    // let arr = ['Ваня', 'Коля', 'Оля',];

                    // arr.forEach(function (item, index, array) {                                 
                    //     console.log(`${item} находиться на ${index} позиции в ${index}`);   item сам элемет массива, index ключ или позиция массива, array это весь масив
                    //                                                                         консоль выведет: Ваня находиться на 0 позиции в 0
                    //                                                                         Коля находиться на 1 позиции в 1
                    //                                                                         Оля находиться на 2 позиции в 2
                    // });

        // тоже самое можно записать в стрелочную функцию   

                    // arr.forEach((item, index, array) => {
                    //     console.log(`${item} находиться на ${index} позиции в ${index}`);
                    // });

        //  или

                    //  arr.forEach(show);     также можно указывать имя отдельной функции 

                    //  function show(item) {
                    //     console.log(item);   консоль выведет Ваня
                    //                                          Коля
                    //                                          Оля
                    //  }


// reduce()   reduceRight() используються для вычисления какого-нибудь единого знаения на основе всего массива
// reduce() - приводит массив к единому значению, то есть редуцируя (сокращая, сводя) его

            // let value = arr.reduce(function(previousValue, item, index, array) {            previousValue - результат предыдущего вызова этой функции, 
            //                                                                                       равен initial при первом вызове (если передан initial)
            //     ...                                                                               item - очередной элемент массива, index его индекс, array сам массив            
            // }, [initial]);                                                                        функция применяется по очереди ко всем элементам массива и 
            //                                                                                       "переносит" свой результат на следующий вызов    

                    // let arrOne = [1, 2, 3, 4];
                    // let reduceValueOne = arrOne.reduce(function(previousValue, item, index, array) {   обьявляем переменную let reduceValueOne, обращаемся к массиву чисел
                    //     return item + previousValue;                                                   в теле функции мы возвращаем сумму текущего значения массива с предыдущим  previousValue                                         
                    // }, 0);                                                                             начальное значение  для  previousValue ставим 0

                    // console.log(reduceValueOne);                                                       консоль выдаст число 10

            // как получилась цифра 10
            // шаг №1
            // previousValue = 0     мы указали ноль  "" }, 0); ""          
            // item = 1              у нас одни let arrOne = ["""1""", 2, 3, 4]                          
            // их сумма = 1          сумма их 1                    

            // шаг №2   
            // previousValue = 1     значение 1 так как результат предыдущей функции 1 (сумма шага №1)
            // item = 2              у нас теперь два let arrOne = [1, """2""", 3, 4] 
            // их сумма = 3          сумма их 1+2=3

            // шаг №3   
            // previousValue = 3      значение 3 так как результат предыдущей функции 3 (сумма шага №2)
            // item = 3               у нас теперь два let arrOne = [1, 2, """3""", 4]
            // их сумма = 6           сумма их 3+3=6

            // шаг №4   
            // previousValue = 6      значение 6 так как результат предыдущей функции 6 (сумма шага №3)
            // item = 4               у нас теперь два let arrOne = [1, 2, 3, """4"""]
            // их сумма = 10          сумма их 6+4=10

    // Если не указывать начальоне значание, то оно будет равно первому элементу массива (previousValue=Ваня)
    // А работа ментода начинается со второго элемента (item = Коля)

    // let arrTwo = ['Ваня', 'Коля', 'Оля',];

    // let reduceValueTwo = arrTwo.reduce(function(previousValue, item, index, array) { 
    //     console.log(previousValue);
    //     console.log(item);
    //     return `${item}, ${previousValue}`;
    // });                                               начальное значение неустановлено
    // console.log(`Пользователи: ${reduceValueTwo}`);   консоль выведит: Ваня
    //                                                                    Коля
    //                                                                    Коля, Ваня
    //                                                                    Оля
    //                                                                    Пользователи: Оля, Коля, Ваня

// reduceRight() - применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению
             //    работает аналогично только проходит по массиву справо налево



// console.log(obj.name); первый способ вывода в консоль
// console.log(obj["name"]); 


// let arr = ["plum.png", "orange.jpg", 6, "apple.bmp", {обьект}, [массив]] Класический массив
// console.log(arr[1]) чтобы вывести с массыва какойто обьект мы должны указать номер под которым он лежит
//                     нумерация начинается с нуля тоесть plum.png под номером ноль


// const arr = ['a','b','c']; - массив это перечень информации по порядку

// const arrObj = {  - массив это частный случай обьекта 
//     0: "a",
//     1: "b",
//     2: "c"
// };

// console.log(arr[1]); выведит b
// console.log(arrObj[1]); 


// const obj = {a: 1, b: 2}; - обьекты структура хранения данных в парном формате        

// const obj = {
//    "Anna": 500, ключ это Anna значение 500

//    "Alice": 800
//     Alice: 800 две одинаковые записи
// };

// const arr = ['a','b','c'];
// const arrObj = { 
//     a: 'a',
//     '1': 'b',
//     2: 'c'
// };

// arrObj.b = '1234'; - одинаковые записи
// arrObj['b'] = '1234';

// console.log(arrObj['b']); 
// console.log(arrObj.b); 



// Задание 2

// let storeName = 'Products';
// let storeDescription = {
//     budget: 10000,
//     employees: ['Jon', 'Mark', 'Sava'],
//     products: {
//         apples: 100,
//         orange: 300
//     },
//     open: true    

// };




                                    // ПРОСТОЕ ОБЩЕНИЕ С ПОЛЬЗОВАТЕЛЕМ

// Вся информация которая приходит от пользователя будет ввиде строки

// prompt - показывает сообщение и запрашивает ввод текста от пользователя.
// alert - показывает сообщение.
// confirm - показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false,
//           если нажата кнопка «Отмена» или Esc с клавиатуры


// alert('Hello')

// const result = confirm("Are you here?");
// console.log(result);

// const answer = prompt("Вам есть 18?", "18");
// console.log(typeof(answer)); выведит строку

// const answer = +prompt("Вам есть 18?", "18"); "+" тип данных строка преобразуется в тип данных цифры
// console.log(answer + 5); выведит сумму  чисел

// const answers = [];

// answers[0] = prompt('Как ваше имя?', '');
// answers[1] = prompt('Как ваша фамилия?', '');
// answers[2] = prompt('Сколько вам лет?', '');
// answers[3] = prompt('Где вы учититесь?', '');

// document.write(answers);





                                        // ИНТЕРПОЛЯЦИЯ(ES6)

// это когда в нутри строки мы можем вставлять переменные

// const category = 'toys';
// console.log('https://someurl.com/' + category);

// интерполяцию мы можем использовать только с косыми кавычками ``
// const category = 'toys';
// console.log(`https://someurl.com/${category}/5`);

// const user = 'Ivan';
// alert(`Привет,${user}`);






                                        // ОПЕРАТОРЫ JS

// Операторы могу быть двух типолв увеличеные и бинарные

// Операнд - это то к чему применяется оператор, или их еще называют аргументами

            // let userAge = 30 - 6;  Числа 30 и 6 это операнды
            // let userHeight = h - y; перерменные h, y тоже операнды( аргументы)

// Бинарными называют операторы которые применяються к двум операндам
// в нашем случае вычитание это бинарный оператор

//             let userAge = 30 - 6;  минус это бинарный оператор который прим к двум аргумтам

// Унарным считается операто, который применяется к одному операнду

//                 let userCash = -800;
 
// в JS поддерживаються такие математические операции

        // let x;
        // Сложение +
        //  х = 5 + 8;
        //  console.log(`Результа сложения: ${x}`);

        //  Вычитание -
        //  х = 9 - 5;
        //  console.log(`Результа вычитания: ${x}`);

        // Умножения *
        // х = 2 * 3;
        //  console.log(`Результа умножения: ${x}`);

        // Деления /
        // х = 10 / 2;
        // console.log(`Результа деления: ${x}`);

        // Взятие остатка от деления %
        // х = 11 % 3;
        // console.log(`Результа взятие остатка от деления: ${x}`);
        // Проверка: 11=3 *3 (неполное частичное от деления) + 2(остаток)

        // Возведение в степень **
        // х = 5 ** 3;
        // console.log(`Результа возведения в степень: ${x}`);
        // Число 5 умноженое на себя 3 раза 5*5*5 = 125

    // Применение оператора сложения к строкам

    //     let resultOne = "Фамилия" + " " + "Имя" + " " + "Отчество";
    //     console.log(resultOne);  консоль: Фамилия Имя Отчество

    // Если в выражении есть строка, то есть то конечный результат тоже будет строкой 
        
    //     let resultTwo = "Фамилия " + 25;
    //     console.log(resultTwo); Консоль: Фамилия 25 

    // порядок и значение не имеет 

    //     let resultTwo = 25 + " Фамилия";
    //     console.log(resultTwo); консоль: 25 Фамилия

    // let resultTwo = 25 + "40";
    // console.log(resultTwo); консоль: 2540

// Унарный оператор сложения

//     Со строками

//         let resultOne = +"25";
//         console.log(resultOne); консоль: 25

//     С цифрами
//         let resultOne = +"25";
//         console.log(resultOne); консоль: 10

        // let user = "25";
        // let admins = "10";
        // console.log(user + admins); консоль: 2510  если применить к бинарному оператору то получитьсч 2510

        // console.log(+user + +admins); консоль: 35 если применить к унарному то получим сложение 25+10=35
        // более длинная запись 
        // console.log(Number(user) + Number(admins)); консоль: 35

    // Приоритеты операторов
    // Умножение и деление выполниться раньше чем сложение и вычитание
    // у собок самый высокий приоритет
    // если у операторов одинаковый приоритет то действия будут выполняться по очереди

// = оператор присваивания
    // let a = 1 + 2; переменной а присваеваем резельтат сложения 1 + 2
    
    // присваивание по цепочке 
    //  let = resultOne = resultTwo = resultThree = 1 + 2; из-за приоритетов сначало выполниться результат 1+2 

        // сокращенная запись вычисления с присваением

        //     let user = 5;
        //     user = user + 3;
        //     user = user * 2;

        //     Можно записать так 

        //     let user = 5;
        //     user += 3;
        //     console.log(user); консоль: 8

        //     user *= 2;
        //     console.log(user); консоль: 16


// Инкремент и декремент 


// Инкремент

// let addUser = 2;
// addUser++;
// console.log(addUser);

// работает также как и 
// addUser = addUser + 1;
// илиaddUser += 1;

// Декремент

// let removedUser = 2;
// removedUser--;
// console.log(removedUser);

// Инкремент / Декремент можно применить только к переменной 
// попытка использовать его на значении, типа 5++, приведет к ошибке

// Постфиксная форма      
    // incr++;
    // decr--;

        // let userCounter = 0;
        // let newUser = userCounter++;
        // console.log(newUser); консоль: 0


//Префиксная форма
    // ++incr;
    // --decr;

        // let userCounter = 0;
        // let newUser = ++userCounter;
        // console.log(newUser); консоль: 1

    // Если нам срузу не нужно получить результат, а нужно только увеличить / уменьшить переменну, 
    // тогда без разницы какую форму использовать

    // Если нужно сразу получить результат то применяем префиксную форму

    // Если нужно увеличить / уменьшить переменную при этом получить значение до получения результата то применяем постфиксную форму

    // Инкремент / Декремент можно применять в любых вырвжениях, при этом приоритет их будет выше,
    // чем у большинства других арифметических операций

        // let userCounter = 0;
        // let newUser = 2 * userCounter++; сначала выполниться инкримент и только потом умножение
        // console.log(newUser); консоль: 2

// Оператор запятая
 
    // Предоставляет возможность вычислять несколько выражений, разделяя их запятой
    // Каждое выражение выполняется,ю но возвращается результат только последнего

    //         let userCounter = (8 + 2, 19 + 1); ве операции выполняться но результа в консоль выведет полько последнего выражения (19+1)
    //         console.log(userCounter); консоль: 20

// Побитовые операторы
        // AND (и)  ( & )
        // QR (или) ( | )

// Операторы сравнения

    // Возвращают логический тип данных со значением true или false

        // Больше: a > b
        // Меньше: a < b
        // Больше или равно: a >= b
        // Меньше или равно: a <= b
        // Равно: a == b
        // Не равно: a != b
        // Строгое равно: a === b
        // Строгое не равно: a !== b

            // console.log(2 > 1); консоль: true
            // console.log(4 < 2); консоль: false
            // console.log(58 == 36); консоль: false
            // console.log(8 != 9); консоль: true

            // let result = 11 > 10;
            // console.log(result); консоль: true

    // Сравнивание строк

        // Алгорит сравнения двух строк простой:
        //     1. сначала сравниваються первые символы строк
        //     2. если первый символ строки больше(меньше) чем первый символ втрой, 
        //        топервая строка больше(меньше) второй. Сравнение завершино
        //     3. если первые символы равны, то таким же образом сравниваються 
        //         уже вторые символы строк
        //     4. сравнивание продолжается, пока не закончиться одна из строк
        //     5. если обе строки заканчиваються одновременно
        //         то они равны. Иначе больше считается более длинная строка

        // JS использует алфавитны й порядок при этом сравнивает строки по символьно тоесть в алфавитном порядке
            
        //     console.log('Б' > 'А'); консоль: true
        //     console.log('Скрипт' > 'Скрипка'); консоль: true

        //     в этом варианте будет сравнивать по количеству символов
        //     console.log('Слайдер' > 'Слайд'); консоль: true

        //     в таблице символов иникод которую использует js маленькие буквы имеют приоритет
        //     console.log('Слайдер' > 'слайдер'); консоль: false


    // При сравнении разных типов данных js будет приводитьть их в число

                // console.log('58' > 10); консоль: true    строка 58 превратиться в число 58
            //     console.log('007' == 7); консоль: true   строка 007 превратиться в цифру

    // Логические значения true будут становиться 1, а false - 0

                // console.log(true == 1); консоль: true       true превратиться в 1 и тогда выражение правдивое
                // console.log(false == 0); консоль: true      false превратиться в ноль


    // Оператор строго раавениства / не равенства проверяет равенство без приведения типов
        // оператор проверяет без приведения типов, тоесть в число преобразовываться ничего не будет
        
                    // console.log(0 === false); консоль: false        ноль не равен false
                    // console.log('007' === 7); консоль: false        строка 007 не равна 7
                    // console.log('58' !== 58); консоль: true         строка 58 не равна число 58

    // Сравнение null и undefined
 
        // строгое равенство

        //     console.log(null === undefined); консоль: false

        // не строгое равенство

        //     console.log(null == undefined); консоль: true

        // сравнение null и 0

        //     console.log(null > 0); консоль: false
        //     console.log(null == 0); консоль: false
        //     console.log(null >= 0); консоль: true

        // сравнение undefined и 0

        //     console.log(undefined > 0); консоль: false
        //     console.log(undefined == 0); консоль: false
        //     console.log(undefined >= 0); консоль: false


    // Чтобы исбежать проблем при сравнивании нужно очень осторожно к любому сравниванию с undefined / null
    // кроме случаев строгого раавениства
    
    // Не использовать сравнения >=,  >,  <, <= с переменными, которые могут принимать значения null / undefined
    
    // если переменная принимает эти значения то стоит добавить для них отдельные проверки


// Логические операторы

    //Оператор ||  "или" 

        // Процес работы ||:
        //     1. вычисляет операнды слева направо
        //     2. каждый операнд конвертирует в логическое значение 
        //     если результат true, останавливается и возвращает исходное значение этого операндам
        //     3. если все операнды являються ложными false, возвращает значение последнего из них

        // булевые значения
            // console.log(true || true); консоль: true
            // console.log(false || true); консоль: true
            // console.log(true || false); консоль: true
            // console.log(false || false); консоль: false

        // разные типы данных

        //     первыей true это 1
        //     console.log(1 || 0); консоль: 1

        //     первыей true это true
        //     console.log(true || 'ИМЯ'); консоль: true

        //     первыей true это 58
        //     console.log(null || 58); консоль: 58

        //     первыей true это ИМЯ
        //     console.log(null || 'ИМЯ' || 0); консоль: ИМЯ

        //     true нет совсем, вернеться последние значение 0
        //     console.log(undefined || '' || null || 0); консоль: 0

                // let userName = '';
                // let userNickName = 'Имя';.

                // let user = userName || userNickName || "Без имени"; true будет Имя, выполнение кода прирвется и в консоль выведит Имя
                // console.log(user); консоль: Имя

            // let admins = 0;
            // let users = 5;
            // admins > users || users++;      сначала выподняется выражение больше(admins > users) это будет false
            //                                  потом выражение ИЛИ false|| users++(users++ будет true и увиличется на 1)
            // console.log(users);  консоль: 6

    // Оператор && (И)

        // && оператор "и" возвращает значение true только если все значение true
        
        // Выполняет такие действия:
        //     1. Вычисляет операнды слева на правдивое
        //     2. каждый операнд преобразует в логическое значение если результат false, 
        //         останавливается и возвращает исходное значение этого операнда
        //     3. если все операнды были true, возвращает значение последнего

        // булевые значения
        //     console.log(true && true); консоль: true
        //     console.log(false && true); консоль: false
        //     console.log(true && false); консоль: false
        //     console.log(false && false); консоль: false

        // разные типы данных

            // ноль будет первый false значить выполнение прерветьбся и выведет 0
            // console.log('ИМЯ' && 0 && 2 && 3); консоль: 0

            // null будет первый false значить выполнение прерветьбся и выведет null
            // console.log(1 && 2 && null && 3); консоль: null

            // все значения будут true
            // console.log('15' && '42'); консоль: 42

        // Приоритет оператора && больше чем ||

        //     console.log(1 && 0 || 2 && 1); консоль: 1






// % опетатор деления
// 
// ! оператор "не"
// typeof -  позволяет определить тип параметра (число, строка, объект). 
//           Оператор возвращает строку, содержащую тип ('number', 'string' , 'object' ). 
//           Для null оператор возвращает 'object' (это признанная ошибка языка)

// const isChecked = true,
//       isClose = true;

// console.log(isChecked && isClose);


// ПРАКТИКА

// const numberOfFilms = +prompt('Сколько фильмов вы уже посмотрели?', '');

// const personalMovieDB = {
//     count: numberOfFilms,
//     movies: {},
//     actors: {},
//     genres: [],
//     privat: false
// };

// const a = prompt('Один из последних просмотренных фильмов?', ''),
//       b = prompt('На сколько оцените его?', ''),
//       c = prompt('Один из последних просмотренных фильмов?', ''),
//       d = prompt('На сколько оцените его?', '');

// personalMovieDB.movies[a] = b;
// personalMovieDB.movies[c] = d;

// console.log(personalMovieDB);



// УСЛОВИЯ

// if(4 == 4) {    условие если 
//     console.log('Ок!');
// } else {
//     console.log('Error');
// }



// const num = 50;

// if (num < 49) {
//     console.log('Error');
// } else if (num > 100) {
//     console.log('Много');
// } else {
//     console.log('Ok!');
// }


// Тернарный оператор
// (num === 50) ? console.log('Ok!') : console.log('Error');


// const num = 50;

// конструкция
// switch всегда идет на строгое сравнение в отличии от обычных условий
// switch (num) {
//     case 49:
//         console.log('Неверно');
//         break;
//     case 100:
//         console.log('Неверно');
//         break;
//     case 50:
//         console.log('В точку!');
//         break;
//     default:
//         console.log('Не в этот раз!');
//         break;    
// }





// ЛОГИЧЕСКИЕ ОПЕРАТОРЫ


// const hamburger = 3;
// const fries = 1;

// if (hamburger === 3 && fries) {         hamburger === 3 - эта часть кода будет выполняться первой так как у оператора === (строгое равно) приоритет по выполнению    &&& (и) этот оператор будет выполняться вторым
//     console.log('Все сыты!');                             мы сравниваем сколько должно быть hamburger
// } else {
//     console.assert.log('Мы уходим');
// }


// оператор и (&&) всегда возвращает первое ложное значение если оно есть на нем код останавливается и дальше код не идет
//                 если все аргументы верны и код дошел до конца то возвращается значение последнего аргумента
                
//                 и (&&) запинается на лжи 
//                 или (||) запинается на правде



// const hamburger = 3;
// const fries = 0;
// const cola = 0;

// if (hamburger || cola || fries) {       как только оператор или (||) находит правду он перестает работать
//     console.log('Все сыты!');
// } else {
//     console.assert.log('Мы уходим');
// }



// let johnReport, alexReport, samReport, mariaReport = 'done';

// console.log(johnReport || alexReport || samReport || mariaReport);
// оператор или вернул правду даже если она стоит в конце списка


// const hamburger = 3;
// const fries = 3;
// const cola = 0;
// const nuggets = 2;

// if (hamburger === 3 && cola ===2 || fries === 3 && nuggets) {
//     console.log('Все сыты!');
// } else {
//     console.assert.log('Мы уходим');
// }

// console.log(hamburger === 3 && cola ===2 || fries === 3 && nuggets);
// ответ 
// Все сыты!
// 2


// console.log( 5 === 5 && 3 > 1 || 5);
// сначала выполняется 3 > 1 у оператора больше приоритет перед другими операторами
// потом выполняется строгое равенство 5 === 5
// потом выполняется логическое И '&&'
// и в последний момент выполняется оператор ИЛИ '||'
// ответ будет 'true'






// ЦИКЛЫ

// Цикл «while»
// let i = 0;
// while (i < 3) { // выводит 0, затем 1, затем 2
//   alert( i );
//   i++;
// }


// Цикл «do…while»
// let i = 0;
// do {
//   alert( i );
//   i++;
// } while (i < 3);


// Цикл «for»
// for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
//     alert(i);
// }


// break полностью прекращает выполнение цикла, отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела
// continue прекращает (перепрыгивает) выполнение тела цикла и передаёт управление на следующую итерацию for



// while – Проверяет условие перед каждой итерацией.
// do..while – Проверяет условие после каждой итерации.
// for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.



// let result = '';
// const length = 7;

// for (let i = 1; i < length; i++) {

//     for ( let j = 0; j<i; j++) {
//         result += '*';
//     }

//     result += '\n';
// }

// console.log(result);








// Задачи#3

//     1, При помощи цикла выведите числа от 5 до 10 в консоль. 5 и 10 включительно. Цикл можно использовать любой

// for (let i = 5; i < 11; i++) {
//     console.log(i);
// }

//   2,  При помощи цикла for вывести числа от 20 до 10 в консоль. 
// В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 13 - остановить весь цикл

// for (let i = 20; i > 10; i--) {

//    if (i === 13) { 
//     break;
//    }

//     console.log(i);

// }

//   3,  При помощи цикла for выведите чётные числа от 2 до 10 включительно

// for (let i = 2; i <= 10; i++) {

//     if (i % 2 === 0) {

//         console.log(i);
//     }

// }

//   4,  Перепишите цикл  for на вариант с while. Результат должен остаться точно таким же. 
// Не создайте бесконечный цикл! Иначе браузер может зависнуть.

//          Цикл, который нужно переписать:
//          
        //  for (let i = 2; i <= 16; i++) {
        //      if (i % 2 === 0) {
        //          continue;
        //      } else {
        //          console.log(i);
        //      }
        //  }


// let i = 2;

// while (i <= 16) {

    
//     if (i % 2 === 0) {
//         i++;
//         continue;
//     } else {
//         console.log(i);
//     }
//     i++;
// }

//   5,  Заполните массив цифрами от 5 до 10 включительно. 
// Помните, что элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

// const arrayOfNumbers = [];

// for (let i = 5; i < 11; i++) {
//     arrayOfNumbers.push(i);
    
// }
    
// console.log(arrayOfNumbers);
    
// второй вариант
// const arrayOfNumbers = [];

// for (let i = 5; i < 11; i++) {
//     arrayOfNumbers[i - 5] = i;
// }

// console.log(arrayOfNumbers);




// Задачи: #4

//    1 Заполните новый массив (result) числами из старого (arr).
//  Количество элементов в массиве можно получить как arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд.
//     Должен получиться точно такой же массив

    const arr = [3, 5, 8, 16, 20, 23, 50];
    const result = [];

    for (let i = 0; i < arr.length; i++) {

            result [i] = arr[i];
    }
    console.log(result);



//    2 Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к ней было добавлено " - done".
//     Для определения типа данных используйте typeof();
//     Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]

    const data = [5, 10, 'Shopping', 20, 'Homework'];
    
    for (let i = 0; i < data.length; i++) {
        if (typeof(data[i]) === 'number') {
            data [i] == data[i] * 2;
        } else if (typeof(data[i]) ==='string'){
            data[i] = `${data[i]} - done`;
        }
    }

console.log(data);



//    3 Разверните массив data наоборот при помощи цикла и запишите данные в пустой массив result.
//     Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]

    const data = [5, 10, 'Shopping', 20, 'Homework'];
    const result = [];

    for (let i = data.length - 1; i >= 0; i--) {
        
        result [i] = data[i];
        result.reverse();
      
    
    }
    console.log(result);




